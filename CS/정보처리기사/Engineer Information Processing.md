# 정보처리기사 [필기]

[TOC]

-----

## 1. 소프트웨어 설계

### 1. 소프트웨어 공학의 개념

- 소프트웨어(Software)의 개념

  - 소프트웨어(Software) : 컴퓨터를 동작시키고 어떤 일의 처리 순서와 방법을 지시하는 명령어의 집합인 프로그램과 프로그램의 수행에 필요한 절차, 규칙, 관련 문서등을 총칭

  - 프로그램 (Program) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합

  - 자료구조 (Data Structure) : 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭하는 것으로 데이터 간의 논리적 관계나 처리 알고리즘

  - 문서 (Paper) : SW를 개발함에 있어 사용자 설명서, 소프트웨어 요구분석서, 평가서, 명세서, 프로젝트 계획서, 검사 계획서 등

- 소프트웨어의 특징 : **상품성, 복잡성, 변경 가능성, 복제성**

- 시스템(System)의 개요와 기본요소
  - 시스템의 개요 : 컴퓨터 처리 가능 자료를 입력 저장 처리 가공해 출력할수 있도록 설계된 정보체계 / 하나의 목적을 위해 다양한 요소가 유기적으로 결합
  - 기본요소 : **입력, 처리, 출력, 제어, 피드백**
- 소프트웨어 위기 (Software Crisis)
  - 컴퓨터의 발달과정에서 SW의 개발속도가 HW의 개발속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없는 문제가 발생
  - 위기의 원인 : **하드웨어 비용을 초과하는 개발 비용의 증가** / **개발 기간의 지연** / **개발 인력 부족 및 인건비 상승** / **성능 및 신뢰성 부족** / **유지보수의 어려움에 따른 엄청난 비용**

-----

- 소프트웨어 공학 (Software Engineering)의 이해
  - 경제적으로 신뢰도 높은 SW를 만들기 위한 방법, 도구와 절차들의 체계
  - IEEE(전기전자학회(미국))는 SW의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근방법이라 정의
- 소프트웨어 공학의 기본원칙
  - 현대적인 프로그래밍 기술을 적용 / 신뢰성 / 사용편리성 / 유지보수성 / 지속적 검증 시행 / 결과에 대한 명확한 기록 유지 / 사용자 원하는 대로 동작 / 최신프로그램 언어, 최신 알고리즘 사용 현황 확인 / SW 개발비용 최소화 / 개발 단계와 소스 코드등의 문서화를 통해 명확성을 유지
- 공학적으로 좋은 SW의 조건
  - 신뢰성 높고 효율적, 사용자 의도대로 동작 / 편리성 제공 및 잠재적 에러 최소화 / 유지보수성 용이
- SW 공학 계층 구조
  - 도구 : 프로세스와 방법을 처리하는 기능을 제공하는 것
  - 방법론 : SW를 설계하는데 기술적인 방법을 제공하는 것
  - 프로세스 : SW의 가장 기초가 되며 개발에 사용하는 방법론과 도구가 적용되는 순서를 의미
- SW 품질
  - 사용자 요구대로 만들어져야 함 / 유지보수 쉬움 / 에러 최소화 / 초반에 정한 비용 맞춰 개발 / 정확한 결과 도출 / 원하는 시간에 원하는 기능 수행
- SW 공학의 목표
  - SW의 생산성과 품질 향상 / 최소의 비용으로 단기간에 시스템에 적합한 SW개발

-----

### 2. 재공학

- 소프트웨어 재공학(Software Reengineering)의 개념
  - SW Crisis를 개발 생산성이 아닌 유지 보수의 생산성으로 해결하려는 방법
  - 현재의 시스템을 변경하거나 재구조화
  - 재구조화는 재공학의 한 유형, 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선
  - SW 재공학 관점에서 가장 연관깊은 유지보수 유형은 예방 유지보수(Preventive Maintenance)
- 재공학의 장점, 목표, 과정
  - 장점 : 개발 시간 및 비용 감소, 품질 향상, 생산성 향상, 신뢰성 향상, 구축 방법에 대한 지식의 공유, 프로젝트 실패 위험 감소
  - 목표 : SW의 유지보수성 향상이 최우선 목표, 복잡한 시스템 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거, 재사용 수월, SW 수명 연장
  - 과정 : **분석(Analysis) > 구성(Restructuring) > 역공학(Reverse Engineering) > 이식(Migration)**
- 재공학의 과정
  - 분석 : 기존 SW의 명세서를 확인, SW의 동작을 이해하고 재공학 대상을 선정
  - 재구성 : SW 구조를 향상시키기 위해 코드를 재구성
  - 역공학 : 원시코드를 분석해 SW 관계를 파악하고 기존 시스템의 설계 정보를 **재발견해 다시 제작**
  - 이식 : 기존 SW 시스템을 새로운 기술 또는 HW 환경에서 사용할 수 있도록 변환
- 리팩토링(Refactoring)
  - SW를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경

-----

- CASE (Computer Aided Software Engineering)
  - SW 개발과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 SW 도구를 사용해 자동화 하는 작업
  - 자료 흐름도 등 다이어그램을 쉽게 작성토록 해주는 SW도구
  - 작업과정 및 데이터 공유를 통해 작업자간의 커뮤니케이션 증대
- CASE가 제공하는 기능
  - 개발을 신속하게, 오류 수정을 쉽게, SW 품질 향상
  - SW 생명주기의 전체 단계 연결, 자동화시켜주는 통합된 도구 제공 기술
  - SW 시스템의 문서 및 명세화를 위한 그래픽 기능 제공
  - SW 개발단계의 표준화를 기할 수 있으며 자료 흐름도 작성기능 제공
  - 모델들 사이의 모순 검사 기능 제공, 다양한 SW 개발모형 지원
  - 원천기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술
- CASE 사용의 장점
  - SW 개발 기간 단축 및 개발 비용 절약으로 SW 생산성 향상
  - 자동화된 검사를 통한 SW 품질 향상
  - 프로그램의 유지보수 간편, SW 모듈의 재사용성 향상
  - SW 개발 주기의 표준안 확립, Sw 개발 기법의 실용화, 문서화등의 용이성 제공, 시스템 수정 및 유지보수 축소
- CASE의 분류
  - 상위(Upper) CASE : 요구분석 및 설계 단계 지원
  - 하위(Lower) CASE : 소스코드 작성, 테스트, 문서화 과정 지원
  - 통합(Integrate) CASE : SW 개발 주기 전체 과정 지원

-----

- 요구사항 분석을 위한 CASE
  - 요구사항 자동분석, 요구사항 분석명세서 기술토록 개발된 도구
  - 표준화와 보고를 통한 문서화 품질 개선, 변경 영향 추적 용이, 명세 유지보수 비용 축소, 교차 참조도와 보고서를 통함 결함, 생략, 불일치등의 발견 용이성
  - 모두가 이용 가능한 DB로 분석자들간의 적절한 조정 기능
  
- 요구사항 분석을 위한 CASE 도구
  - **SADT(Structured Analysis and Design Technique)** : SoftTech사 개발, 구조적 요구분석을 하기 위해 **블록 다이어그램**을 채택한 자동화 도구
  
  - SREM(Software Requirements Engineering Methodology) : TRW 사 개발, 실시간 처리 SW 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발, RSL[^1]과 REVS[^2]를 사용
  
    

[^1]: 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술언어
[^2]: RSL로 기술된 요구사항들을 자동으로 분석해 요구사항 분석 명세서를 출력하는 분석기

-----

### 3. 소프트웨어 개발 방법론

- 소프트웨어 생명주기(Software Life Cycle)
  - SW 제품의 개념 형성에서 시작해 운용/유지보수에 이르기까지 변화의 모든 과정
  - 타당성 검토 > 개발 계획 > 요구사항 분석 > 설계 > 구현 > 테스트 > 운용 > 유지보수
- 폭포수 모형(Waterfall Model)의 개요
  - 선형 순차적 모델, Boehm이 제시한 고전적 생명주기 모형
- 나선형 모형(Spiral Model)
  - Boehm 제시, 반복적 작업 수행하는 점증적 생명주기 모형
  - 점증적 모형, 집중적 모형이라고 하며 유지보수 과정 필요 X
  - SW 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적
  - 나선을 따라 돌아가며 각 개발 순서를 반복 수행하는 점진적 방식으로 누락된 요구사항 추가가능
  - 계획 및 초기 요구분석 > 1차 위험분석 > 1차 프로토타입 개발 > 1차 고객평가 > (**계획수립 > 위험분석 > 개발 및 검증 > 고객 평가**) > 반복
- 나선형 모형의 개발 단계
  - 계획수립 : 기능, 제약등의 세부적 계획단계
  - 위험분석 : 위험 요소 분석 및 해결 방안 설정 단계
  - 개발 및 검증 : 기능 개발 및 검증 단계
  - 고객 평가 및 다음 단계 수립 : 결과물 평가 및 추후 단계 진행 여부를 결정
- 하향식과 상향식 설계
  - 하향식 설계 : SW 설계 시 제일 상위에 있는 Main User Function에서 시작해 기능을 하위 기능들로 나눠가며 설계하는 방식
  - 상향식 설계 : 기본적인 컴포넌트를 먼저 설계한 다음 상위 수준의 컴포넌트를 설계하는 방식
- 프로토타입(Prototype Model)의 개요
  - 실제 개발될 시스템의 견본(Prototype)을 미리 만들어 최종 결과물을 예측하는 모형
  - 개발 완료 후에 문제점을 알 수있는 폭포수 모형의 단점을 보완키 위한 모형
- HIPO(Hierarchy Input Process Output)
  - 입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법
  - 일반적으로 **가시적 도표(Visual Table of Contents), 총체적 다이어그램 (Overview Diagram), 세부적 다이어그램(Detail Diagram)** 으로 구성
  - 구조도(가시적 도표), 개요, 도표(Index Diagram), 상세도표로 구성
  - 가시적 도표는 전체적 기능과 흐름을 보여주는 구조
  - 기능과 자료의 의존관계 동시 표현 가능
  - 보기 쉽고 이해하기 쉬우며 유지보수 용이
  - 하향식 소프트웨어 개발을 위한 문서화 도구
- V-모델
  - 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델
  - 세부적 프로세스로 구성되어 신뢰도 높은 시스템 개발에 효과적
  - 생명주기 초반부터 테스트 작업 지원
  - 코드 뿐만 아니라 요구사항과 설계 결과도 테스트 할 수 있어야 함
  - 폭포수 모형보다 반복과 재처리 과정 명확
  - 테스트 작업을 단계별로 구분하므로 책임이 명확
  - ![image-20230101221315131](https://user-images.githubusercontent.com/107028310/210172786-6de657de-1280-4f69-a338-33c3ca0054bb.png)

---

- 애자일(Agile) 개발 방법론
  - 특정 방법론이 아닌 SW를 빠르고 낭비없이 제작키 위해 고객과에 협업에 초점, 설계 변경에 신속히 대응해 요구사항을 수용가능
  - 절차와 도구보다 개인과 소통을 중시, 고객과의 피드백 중시
  - SW가 잘 실행됨에 가치를 두며 SW 배포 시차를 최소화 가능
  - 특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션 변화
  - **종류 : 익스트림프로그래밍(XP), 스크럼(Scrum), 린(Lean), DSDM(Dynamic System Development Method), FDD(Feature Driven Development), Crystal, ASD(Adaptive Software Development), DAD(Disciplined Agile Delivery)**
- Agile 선언문
  - 프로세스나 도구보다 개인과의 소통이 중요 / 완벽한 문서보다 실행되는 SW가 중요 / 계약 협상보다 고객과의 협업이 중요 / 계획 이행보다 변경에 대한 응답이 중요

---

- XP(eXtreme Programming)

  - 1999 Kent Beck 제안, 개발 단계 중 요구사항이 시시각각 변동이 심한 경우 적합한 방법론
  - 요구에 맞는 양질의 SW 신속하게 제공 목표
  - 요구사항을 모두 정의해 놓고 작업을 진행 X, 요구사항이 변경되는 것을 적용하는 방식으로 예측성보다 적응성에 높은 가치 부여
  - 고객의 참여와 개발 과정의 반복을 극대화해 생산성을 향상

- XP 핵심 가치

  - **소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향**
  - **단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제**
  - **피드백(Feedback) : SW개발에서 변화는 불가피, 이러한 변화는 지속적 테스트와 통합, 반복적 결함 수정 등 빠르게 피드백**
  - **용기(Courage) : 고객 요구사항 변화에 능동적으로 대응**
  - **존중(Respect) : 개발 팀원간의 상호 존중**

- XP Process

  - ![image-20230101222311746](https://user-images.githubusercontent.com/107028310/210172801-260eb8b9-9e68-45d4-bdfa-35d04ad9db98.png)
  - User Story : 일종의 요구사항으로 UML의 유즈케이스와 같은 목적으로 생성되나 형식이 없고 고객에 의해 작성
  - Spike : 어려운 요구사항, 잠재적 솔루션을 고려하기 위해 작성하는 간단한 프로그램
  - Release Planning : 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공, 부분/전체 개발 완료 시점에 대한 일정 수립
  - Iteration : 하나의 릴리즈를 세분화 한 단위, 1~3주 단위로 진행, Iteration(반복) 진행 중 새 스토리가 추가될 때 진행 중 반복이나 다음 반복에 추가 가능
  - Acceptance Test : 릴리즈 단위의 개발이 구현되었을 때 진행하는 테스트, 유저 스토리 요구사항을 확인해 고객이 직접 테스트, 오류 발견 시 다음 반복에 추가, 테스트 후 고객 요구사항에 따라 우선순위 변경 가능, 완료 후 다음 반복 진행
  - Small Realease : 릴리즈 단위를 기능별로 세분화 해 고객의 반응을 기능별로 확인 가능, 완제품일 때 고객에 의한 최종 테스트 진행 후 고객에게 제공

- XP의 12가지 실천사항(Practice)

  | 구분                 | 12 실천사항               | 설명                                                         |
  | -------------------- | ------------------------- | :----------------------------------------------------------- |
  | Fine Scale Feedback  | Pair Programming          | 두 사람이 짝이되어 한사람을 코딩, 한사람은 검사 수행 / 코드 책임 공유 / 비형식적인 검토 수행 / 코드 개선을 위한 리팩토링 장려 |
  |                      | Planning Game             | 게임처럼 선수와 규칙, 목표를 두고 기획                       |
  |                      | Test Driven Development   | 실제 코드를 작성하기 전 단위 테스트부터 작성 및 수행, 이를 기반으로 코드 작성 |
  |                      | Whole Team                | 개발 효율을 위해 고객을 프로젝트 팀원으로 상주               |
  | Continuous Process   | Continuous Integration    | 상시 빌드 및 배포를 할 수 있는 상태로 유지                   |
  |                      | Design Improvement        | 기능 변경 없이 중복성, 복잡성 제거 / 커뮤니케이션 향상 / 단순화 / 유연성 등을 위한 재구성을 수행 |
  |                      | Small Releases            | 짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 함 |
  | Shared Understanding | Coding Standards          | 소스 코드 작성 포맷과 규칙들을 표준화 된 관례에 따라 작성    |
  |                      | Collective Code Ownership | 시스템에 있는 소스 코드는 팀의 모든 프로그래머가 누구든 언제라도 수정 |
  |                      | Simple Design             | 가능한 가장 간결한 디자인 상태를 유지                        |
  |                      | System Metaphor           | 최종 개발되어야 할 시스템의 구조를 기술                      |
  | Programmer Welfare   | Sustatinable Pace         | 일주일에 40시간 이상 작업 금지, 2주 연속 오버타임 금지       |

- 효과적인 프로젝트 관리를 위한 3대 요소

  - **사람(People) : 인적자원 / 문제(Problem) : 문제 인식 / 프로세스(Process) : 작업 계획**	[3P라 총칭]

- 정형 기술 검토 지침 사항

  - 의제와 그 범위를 유지 / 참가자 수 제한 / 체크 리스트 작성 및 자원, 시간 일정 할당 / 개발자가 아닌 제품의 검토에 집중 / 논쟁과 반박 제한 / 검토 과정과 결과를 재검토

---

### 4. SCRUM

- SCRUM 개념과 특징
  - 요구사항 변경에 신속하게 대처할 수 있도록 반복적이고 점진적인 소규모 팀원 간 활발한 소통과 협동심이 필요한 팀 중심의 SW 개발 방법론
  - 신속하게 반복적으로 실제 작동하는 SW 제공
  - 개발자들의 팀 구성과 각 구성원의 역할, 일정 결과 물 및 그 외 규칙을 정하는 것
  - 기능 개선점에 우선순위 부여, 개발 주기 동안 실제 동작 가능한 결과 제공
  - 개발 주기마다 적용된 기능이나 개선점의 리스트 제공
  - 커뮤니케이션을 위해 개방된 공간에서 개발, 매일 15분 정도의 회의
  - 팀원 스스토 팀을 구성 (Self Organizing)
  - 개발 작업에 관한 모든 것을 팀원 스스로 해결해야 함 (Cross Functional)
  
- SCRUM 기본 원리

  - 기능 협업을 기준으로 배치된 팀은 스프린트 단위로 SW 개발
  - 스프린트는 고정된 30일의 반복으로 시행 작업은 고정
  - 요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 함
  - 정해진 시간 지키기, 작업 제품 백로그에 기록
  - 일일 스탠드 업 미팅, 일일 스크럼을 통한 기본 정보 교환

- SCRUM팀의 역할

  - ![image](https://user-images.githubusercontent.com/107028310/210216818-2a805aff-1afa-4c54-8dba-83f710d02e69.png)

    | 담당자                      | 역할                                                         |
    | --------------------------- | ------------------------------------------------------------ |
    | 제품 책임자 (Product Owner) | 개발 목표에 이해도가 높은 의뢰자, 사용자가 담당 / 요구사항을 파악해 기능 목록(Product Backlog) 작성 / 테스트 수행 및 우선순위 갱신 / 스프린트 계획 수립까지만 임무를 수행 / 스트린트 시작 시 팀 운영에 관여 X |
    | 스크럼 마스터               | 업무 배분만 하고 일은 강요 X / 팀 스스로 조직하고 관리하도록 지원 / 개발 장애 요소 제거 / 스크럼 원칙 가치 지원 |
    | 스크럼 팀                   | 제품 책임자, 스크럼 마스터를 제외한 팀원이 해당, 팀원은 5~9명 / 기능을 작업단위로 분류, 스토리로 도출 구현 / 일정을 추정해 책임자에게 전달 / 결과물을 책임자에게 시연 / 매일 스크럼 회의 |


---

- SCRUM 과정
  - Product Backlog : 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록 / 지속적 업데이트 / 릴리즈 계획 수립
  - Sprint : 작은 단위의 개발 업무를 단기간에 전력 질주하여 개발 / 반복 주기마다 진척도 보고
  - Spring Planning Meeting : Product Backlog 에서 진행할 목록을 선택 / 단기 일정 수립, 요구사항을 Task 단위로 나눔 / Sprint Backlog 작성, 결과물 모습 결정 / SCRUM Master 에게 보고해 이해관계자로부터 수행에 필요한 요구사항 지원
  - Daily SCRUM Meeting : 매일 약속된 시간에 짧게 서서 진행 점검 / 완료된 작업항목을 스프린트 현황판에 갱신 / 스크럼 마스터는 방해요소를 찾아 제거 후 작업 시간을 **소멸차트(Burn down Chart)**에 기록
  - Finished Work : 모든 스프린트 주기 완료 시 제품 기능 목록(Product Backlog)의 개발 목표물 완성
  - Sprint Review : 개발자와 사용자 같이 참석 / 반복주기 종료 시 생성된 제품에 대해 검토 / 개선 사항에 대해 제품 책임자는 피드백을 정리 후 백로그 작성
  - Sprint Retrospective : 개선점이 없는지 살펴보고 문제점 기록 정도로 진행 / 강점을 찾아 팀 능력 극대화 / 추정속도와 개발속도 비교해 차이 원인 분석

---

### 5. 현행 시스템 분석

- 현행 시스템 분석의 정의와 목적
  - 현행 시스템이 어떤 하위 시스템으로 구성되어 있는지 파악하는 절차
  - 현행 시스템의 제공 기능과 타 시스템과의 정보 교환 분석을 파악
  - 기술 요소와 SW, HW 파악
  - 목적 : 개발 시스템의 개발 범위 확인 및 이행 방향성 설정

- 현행 시스템 파악 절차
  - 1단계 : 시스템 구성 파악 - 시스템 기능 파악 - 시스템 인터페이스 현황 파악
  - 2단계 : 아키텍처 파악 - SW구성 파악
  - 3단계 : 시스템 HW 현황 파악 - 네트워크 구성 파악

- 시스템 아키텍처
  - 시스템 내 상위 시스템과 하위 시스템이 어떤 관계로 상호작용하는지 각각의 동작 원리와 구성을 표현
  - 단위 업무 시스템별로 아키텍처가 다른 경우 핵심 기간 업무 처리 시스템을 기준
  - 시스템의 전체 구조, 행위 그리고 행위 원리를 나타내며 시스템이 어떻게 작동하는지 설명
  - 시스템의 목적 달성을 위해 각 컴포넌트를 식별하고 컴포넌트의 상호작용을 통해 어떻게 정보 교환이 발생하는지 설명
  - 시스템 아키텍처 <-> SW 아키텍처 -> SW 상세설계


---

- 시스템 구성 파악

  - 조직 내 주요업무를 기간 업무와 지원업무로 구분해 기술

  - 모든 단위 업무를 파악, 시스템 내 명칭, 기능 등 주요 기능 명시

  - 예시

    | 구분     | 시스템명    | 시스템 내용                                       |
    | -------- | ----------- | ------------------------------------------------- |
    | 기간업무 | 단위 A 업무 | 기간 단위 업무 A 처리를 위한 A1,A2 등의 기능 제공 |
    |          | 단위 B 업무 | 기간 단위 업무 B 처리를 위한 B1,B2 등의 기능 제공 |
    | 지원업무 | 단위 C 업무 | 지원 업무 C 처리를 위한 C1, C2 등의 기능 제공     |

- 시스템 기능 파악

  - 단위 업무 시스템이 현재 제공하는 기능을 주요, 하부 기능으로 구분해 계층형으로 표시
  - 예시

  | 시스템명           | 기능 L1 | 기능 L2      | 기능 L3      |
  | ------------------ | ------- | ------------ | ------------ |
  | A 단위 업무 시스템 | 기능1   | 하부 기능 11 | 세부기능 111 |
  |                    |         |              | 세부기능 112 |
  |                    |         | 하부기능 12  | 세부기능 121 |
  |                    |         |              | 세부기능 122 |
  |                    | 기능2   | 하부기능 21  | 세부기능 211 |
  |                    |         |              | 세부기능 212 |

- 인터페이스 현황 파악

  - 현행 시스템의 단위 업무 시스템이 타 단위 업무 시스템과 주고받는 데이터의 연계 유형, 데이터 형식과 종류, 프로토콜 및 주기 등을 명시

  - 데이터형식 (예 : XML, 고정 Format, 가변 Format) / 통신 규약 (예 : TCP/IP, X.25) / 연계 유형 (예 : EAI, FEP)

  - 예시

    | 송신시스템         | 수신시스템         | 연동데이터 | 연동형식 | 통식규약 | 연계유형 | 주기  |
    | ------------------ | ------------------ | ---------- | -------- | -------- | -------- | ----- |
    | A 단위 업무 시스템 | 대외 기관 시스템 C | 연체정보   | XML      | TCP / IP | EAI      | 1시간 |
    | B 단위 업무 시스템 | 대외 기관 시스템 D | 신용정보   | XML      | X.25     | FEP      | 수시  |

- EAI(Enterprise Application Integration, 기업 애플리케이션 통합)

  - 기업 내 컴퓨터 애플리케이션들을 현대화하고, 통합하고, 조정하는 것을 목표로 세운 계획, 방법 및 도구를 의미

- **FEP(Front-End Processor, 전위 처리기)**

  - 입력 데이터를 프로세서가 처리하기 전에 미리 처리해 처리시간을 줄여주는 프로그램이나 HW
  - 여러 통신 라인을 중앙 컴퓨터에 연결하고 터미널의 메시지가 보낼 상태로 있는지 받을 상태로 있는지 검색, 통신라인의 에러 검출


---

- 소프트웨어 구성 파악
  - 시스템 내의 단위 업무 시스템의 업무 처리용 SW의 품명, 용도, 라이선스 적용 방식, 라이선스 수를 명시
  - 시스템 구축 시 많은 예산 비중을 차지 하므로 라이선스 적용 방식과 보유한 라이선스 수량 파악이 중요
  - 라이선스 적용 방식 단위 : 사이트, 서버, 프로세서, 코어, 사용자 수

- 하드웨어 구성 파악
  - 각 단위 업무 시스템의 서버 위치 및 주요 사양, 수량, 이중화 여부를 파악
  - 서버 사양 : CPU 처리 속도, 메모리 크기, 하드 디스크의 용량
  - 서버 이중화 : 장애 시 서비스의 유지를 위하여 운영
  - 기간 업무의 장애 대응 정책에 따라 필요 여부가 달라짐
  - 시스템에 이중화가 적용되어 있다면 대부분 목표 시스템도 이중화가 요구되므로 그에 따른 기술 난이도, 비용 증가 가능성 파악

- 네트워크 구성 파악
  - 현행 업무 처리 시스템의 네트워크 구성 형태를 그림으로 표현
  - 장애 발생 시 추적 및 대응의 다양한 용도
  - 서버의 위치, 서버 간 연결 방식 등을 파악
  - 물리적인 위치 관계, 조직 내 보안 취약성 분석 및 대응 방안 파악

- 개발 기술 환경 분석
  - 개발 대상 시스템의 플랫폼, OS, DBMS, Middle Ware 등을 분석


---

- 플랫폼
  - 응용 SW + (HW + 시스템 SW)
  - 다양한 애플리케이션이 작동하는 기본이 되는 운영체제 SW
  - 종류 : JAVA 플랫폼, .NET 플랫폼, iOS, Android, Windows
  - 기능 : 개발/운영/유지보수 비용의 감소, 생산성 향상, 동일 플랫폼 간의 네트워크 효과

- 플랫폼 성능 특성 분석
  - 현행 시스템의 사용자가 요구사항을 통해 시스템 성능상의 문제를 요구할 경우 플랫폼 성능 분석을 통해 사용자가 느끼는 속도를 파악하고 개선 방향 제시
  - 특성 분석 항목 : 응답시간 (Response Time), 가용성(Availability), 사용률(Utilization)

- 플랫폼 성능 특성 분석 방법
  - **기능 테스트(Perfomance Test) : 현재 시스템의 플랫폼을 평가할 수 있는 기능 테스트를 수행**
  - **사용자 인터뷰 : 사용자를 대상으로 현행 플랫폼 기능의 불편함을 인터뷰**
  - **문서 점검 : 플랫폼과 유사한 플랫폼의 기능 자료를 분석**


---

- OS(Operating System, 운영체제) 정의 및 기능
  - HW, SW 자원 관리 및 공통 서비스 제공, 사용자와의 인터페이스를 제공
  - 종류 : Windows, Android, iOS, UNIX, LINUX, Mac OS 등

- 현행 시스템의 OS 분석 항목 및 고려사항
  - **분석 항목 : 현재 정보 시스템의 OS 종류와 버전, 패치 일자, 백업 주기 분석**
  - **고려사항 : 가용성, 성능, 기술지원, 주변기기, 구축 비용(TCO[^3])**
  - **메모리 누수 : 실행 SW가 정상 종료되지 않고 남아 있는 증상**


[^3]: Total Cost of Ownership : 일정 기간 자산 획득에 필요한 직간접적인 총비용으로 HW, SW 구매비용, 운영 교육, 기술지원, 유지보수, 손실, 에너지비용

- 오픈소스 라이선스 종류
  - **소스 코드가 공개되어 누구나 특별한 제한 없이 소스 사용 가능하며 대표적으로 LINUX가 있다**
  - **GNU(GNU's Not Unix) : 컴퓨터 프로그램을 물론 모든 관련 정보를 돈 주고 구매하는 것에 반대하는 기본 이념. 예) LINUX**
  - **GNU GPLv1(General Public License) : 소스 코드를 공개 하지 않으면서 바이너리만 배포하는 것을 금지, 사용할 수 있는 쉬운 소스 코드를 같이 배포**
  - **BSD(Berkeley Software Distribution) : 아무나 개작, 수정한 것을 제한 없이 배포 가능하다. 단, 수정본의 재배포는 의무X. 미공개 상용 SW에서도 사용**
  - **Apache 2.0 : Apache 재단 소유의 SW 적용을 위해 제공하는 라이선스. 소스 코드 수정 배포 시 Apache 2.0 포함. 예) Android, HADOOP[^4]**

[^4]: 다수의 저렴한 컴퓨터를 하나처럼 묶어 대량 데이터(Big Data)를 처리하는 기술

---

- DBMS(DataBase Management System)

  - **종속성과 중복성의 문제**를 해결하기 위해서 제안된 데이터베이스 시스템
  - 응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리
  - 데이터베이스의 구성, 접근 방법, 관리 유지에 대한 모든 책임
  - 종류 : Oracle, IBM DB2, Microsoft SQL Server, MySQL, SQ Lite, MongeDB, Redis

- 현행 시스템 DBMS 분석

  - DBMS 종류, 구성 방식, 저장 용량, 백업 주기, 제작사의 유지보수 여부 가능성을 분석
  - 테이블 수량, 데이터 증가 추이, 백업 방식 등을 분석
  - 논리/물리 테이블의 구조도를 파악, 각 테이블의 정규화 정도, 조인 난이도, 각종 프로시저, 트리거 등을 분석

- DBMS 분석 시 고려사항

  - | 구분        | 설명                                                         |
    | ----------- | ------------------------------------------------------------ |
    | 가용성      | 장시간 운영 시 장애 발생 가능성, 패치 설치를 위한 재 기동 시간과 이중화 및 복제 지원, 백업 및 복구 편의성 등을 고려 |
    | 성능        | 대규모 데이터 처리 성능(불할 테이블의 지원 여부), 대량 거래 처리 성능 및 다양한 튜닝 옵션 지원, 비용 기반 최적화 지원 및 설정의 최소화 등을 고려 |
    | 기술지원    | 제조업체의 안정적인 기술 지원, 같은 DBMS 사용자들 간의 정보 공유 여부와 오픈소스 여부 등을 고려 |
    | 상호 호환성 | 설치 가능한 운영체제 종류를 파악하여 다양한 운영체제에서 지원되는지 확인. JDBC, ODBC 등 상호 호환성이 좋은 제품 선택 |
    | 구축 비용   | 라이선스 정책 및 비용, 유지 또는 관리 비용, 총 소유 비용(TCO)을 고려 |


---



