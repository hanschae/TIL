# 정보처리기사 [필기]

[toc]

-----

## 1. 소프트웨어 설계

### 1. 소프트웨어 공학의 개념

- 소프트웨어(Software)의 개념

  - 소프트웨어(Software) : 컴퓨터를 동작시키고 어떤 일의 처리 순서와 방법을 지시하는 명령어의 집합인 프로그램과 프로그램의 수행에 필요한 절차, 규칙, 관련 문서등을 총칭

  - 프로그램 (Program) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합

  - 자료구조 (Data Structure) : 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭하는 것으로 데이터 간의 논리적 관계나 처리 알고리즘

  - 문서 (Paper) : SW를 개발함에 있어 사용자 설명서, 소프트웨어 요구분석서, 평가서, 명세서, 프로젝트 계획서, 검사 계획서 등

- 소프트웨어의 특징 : **상품성, 복잡성, 변경 가능성, 복제성**

- 시스템(System)의 개요와 기본요소
  - 시스템의 개요 : 컴퓨터 처리 가능 자료를 입력 저장 처리 가공해 출력할수 있도록 설계된 정보체계 / 하나의 목적을 위해 다양한 요소가 유기적으로 결합
  - 기본요소 : **입력, 처리, 출력, 제어, 피드백**
- 소프트웨어 위기 (Software Crisis)
  - 컴퓨터의 발달과정에서 SW의 개발속도가 HW의 개발속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없는 문제가 발생
  - 위기의 원인 : **하드웨어 비용을 초과하는 개발 비용의 증가** / **개발 기간의 지연** / **개발 인력 부족 및 인건비 상승** / **성능 및 신뢰성 부족** / **유지보수의 어려움에 따른 엄청난 비용**

-----

- 소프트웨어 공학 (Software Engineering)의 이해
  - 경제적으로 신뢰도 높은 SW를 만들기 위한 방법, 도구와 절차들의 체계
  - IEEE(전기전자학회(미국))는 SW의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근방법이라 정의
- 소프트웨어 공학의 기본원칙
  - 현대적인 프로그래밍 기술을 적용 / 신뢰성 / 사용편리성 / 유지보수성 / 지속적 검증 시행 / 결과에 대한 명확한 기록 유지 / 사용자 원하는 대로 동작 / 최신프로그램 언어, 최신 알고리즘 사용 현황 확인 / SW 개발비용 최소화 / 개발 단계와 소스 코드등의 문서화를 통해 명확성을 유지
- 공학적으로 좋은 SW의 조건
  - 신뢰성 높고 효율적, 사용자 의도대로 동작 / 편리성 제공 및 잠재적 에러 최소화 / 유지보수성 용이
- SW 공학 계층 구조
  - 도구 : 프로세스와 방법을 처리하는 기능을 제공하는 것
  - 방법론 : SW를 설계하는데 기술적인 방법을 제공하는 것
  - 프로세스 : SW의 가장 기초가 되며 개발에 사용하는 방법론과 도구가 적용되는 순서를 의미
- SW 품질
  - 사용자 요구대로 만들어져야 함 / 유지보수 쉬움 / 에러 최소화 / 초반에 정한 비용 맞춰 개발 / 정확한 결과 도출 / 원하는 시간에 원하는 기능 수행
- SW 공학의 목표
  - SW의 생산성과 품질 향상 / 최소의 비용으로 단기간에 시스템에 적합한 SW개발

-----

### 2. 재공학

- 소프트웨어 재공학(Software Reengineering)의 개념
  - SW Crisis를 개발 생산성이 아닌 유지 보수의 생산성으로 해결하려는 방법
  - 현재의 시스템을 변경하거나 재구조화
  - 재구조화는 재공학의 한 유형, 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선
  - SW 재공학 관점에서 가장 연관깊은 유지보수 유형은 예방 유지보수(Preventive Maintenance)
- 재공학의 장점, 목표, 과정
  - 장점 : 개발 시간 및 비용 감소, 품질 향상, 생산성 향상, 신뢰성 향상, 구축 방법에 대한 지식의 공유, 프로젝트 실패 위험 감소
  - 목표 : SW의 유지보수성 향상이 최우선 목표, 복잡한 시스템 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거, 재사용 수월, SW 수명 연장
  - 과정 : **분석(Analysis) > 구성(Restructuring) > 역공학(Reverse Engineering) > 이식(Migration)**
- 재공학의 과정
  - 분석 : 기존 SW의 명세서를 확인, SW의 동작을 이해하고 재공학 대상을 선정
  - 재구성 : SW 구조를 향상시키기 위해 코드를 재구성
  - 역공학 : 원시코드를 분석해 SW 관계를 파악하고 기존 시스템의 설계 정보를 **재발견해 다시 제작**
  - 이식 : 기존 SW 시스템을 새로운 기술 또는 HW 환경에서 사용할 수 있도록 변환
- 리팩토링(Refactoring)
  - SW를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경

-----

- CASE (Computer Aided Software Engineering)
  - SW 개발과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 SW 도구를 사용해 자동화 하는 작업
  - 자료 흐름도 등 다이어그램을 쉽게 작성토록 해주는 SW도구
  - 작업과정 및 데이터 공유를 통해 작업자간의 커뮤니케이션 증대
- CASE가 제공하는 기능
  - 개발을 신속하게, 오류 수정을 쉽게, SW 품질 향상
  - SW 생명주기의 전체 단계 연결, 자동화시켜주는 통합된 도구 제공 기술
  - SW 시스템의 문서 및 명세화를 위한 그래픽 기능 제공
  - SW 개발단계의 표준화를 기할 수 있으며 자료 흐름도 작성기능 제공
  - 모델들 사이의 모순 검사 기능 제공, 다양한 SW 개발모형 지원
  - 원천기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술
- CASE 사용의 장점
  - SW 개발 기간 단축 및 개발 비용 절약으로 SW 생산성 향상
  - 자동화된 검사를 통한 SW 품질 향상
  - 프로그램의 유지보수 간편, SW 모듈의 재사용성 향상
  - SW 개발 주기의 표준안 확립, Sw 개발 기법의 실용화, 문서화등의 용이성 제공, 시스템 수정 및 유지보수 축소
- CASE의 분류
  - 상위(Upper) CASE : 요구분석 및 설계 단계 지원
  - 하위(Lower) CASE : 소스코드 작성, 테스트, 문서화 과정 지원
  - 통합(Integrate) CASE : SW 개발 주기 전체 과정 지원

-----

- 요구사항 분석을 위한 CASE
  - 요구사항 자동분석, 요구사항 분석명세서 기술토록 개발된 도구
  - 표준화와 보고를 통한 문서화 품질 개선, 변경 영향 추적 용이, 명세 유지보수 비용 축소, 교차 참조도와 보고서를 통함 결함, 생략, 불일치등의 발견 용이성
  - 모두가 이용 가능한 DB로 분석자들간의 적절한 조정 기능
  
- 요구사항 분석을 위한 CASE 도구
  - **SADT(Structured Analysis and Design Technique)** : SoftTech사 개발, 구조적 요구분석을 하기 위해 **블록 다이어그램**을 채택한 자동화 도구
  
  - SREM(Software Requirements Engineering Methodology) : TRW 사 개발, 실시간 처리 SW 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발, RSL[^1]과 REVS[^2]를 사용
  
    

[^1]: 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술언어
[^2]: RSL로 기술된 요구사항들을 자동으로 분석해 요구사항 분석 명세서를 출력하는 분석기

-----

### 3. 소프트웨어 개발 방법론

- 소프트웨어 생명주기(Software Life Cycle)
  - SW 제품의 개념 형성에서 시작해 운용/유지보수에 이르기까지 변화의 모든 과정
  - 타당성 검토 > 개발 계획 > 요구사항 분석 > 설계 > 구현 > 테스트 > 운용 > 유지보수
- 폭포수 모형(Waterfall Model)의 개요
  - 선형 순차적 모델, Boehm이 제시한 고전적 생명주기 모형
- 나선형 모형(Spiral Model)
  - Boehm 제시, 반복적 작업 수행하는 점증적 생명주기 모형
  - 점증적 모형, 집중적 모형이라고 하며 유지보수 과정 필요 X
  - SW 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적
  - 나선을 따라 돌아가며 각 개발 순서를 반복 수행하는 점진적 방식으로 누락된 요구사항 추가가능
  - 계획 및 초기 요구분석 > 1차 위험분석 > 1차 프로토타입 개발 > 1차 고객평가 > (**계획수립 > 위험분석 > 개발 및 검증 > 고객 평가**) > 반복
- 나선형 모형의 개발 단계
  - 계획수립 : 기능, 제약등의 세부적 계획단계
  - 위험분석 : 위험 요소 분석 및 해결 방안 설정 단계
  - 개발 및 검증 : 기능 개발 및 검증 단계
  - 고객 평가 및 다음 단계 수립 : 결과물 평가 및 추후 단계 진행 여부를 결정
- 하향식과 상향식 설계
  - 하향식 설계 : SW 설계 시 제일 상위에 있는 Main User Function에서 시작해 기능을 하위 기능들로 나눠가며 설계하는 방식
  - 상향식 설계 : 기본적인 컴포넌트를 먼저 설계한 다음 상위 수준의 컴포넌트를 설계하는 방식
- 프로토타입(Prototype Model)의 개요
  - 실제 개발될 시스템의 견본(Prototype)을 미리 만들어 최종 결과물을 예측하는 모형
  - 개발 완료 후에 문제점을 알 수있는 폭포수 모형의 단점을 보완키 위한 모형
- HIPO(Hierarchy Input Process Output)
  - 입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법
  - 일반적으로 **가시적 도표(Visual Table of Contents), 총체적 다이어그램 (Overview Diagram), 세부적 다이어그램(Detail Diagram)** 으로 구성
  - 구조도(가시적 도표), 개요, 도표(Index Diagram), 상세도표로 구성
  - 가시적 도표는 전체적 기능과 흐름을 보여주는 구조
  - 기능과 자료의 의존관계 동시 표현 가능
  - 보기 쉽고 이해하기 쉬우며 유지보수 용이
  - 하향식 소프트웨어 개발을 위한 문서화 도구
- V-모델
  - 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델
  - 세부적 프로세스로 구성되어 신뢰도 높은 시스템 개발에 효과적
  - 생명주기 초반부터 테스트 작업 지원
  - 코드 뿐만 아니라 요구사항과 설계 결과도 테스트 할 수 있어야 함
  - 폭포수 모형보다 반복과 재처리 과정 명확
  - 테스트 작업을 단계별로 구분하므로 책임이 명확
  - ![image-20230101221315131](https://user-images.githubusercontent.com/107028310/210172786-6de657de-1280-4f69-a338-33c3ca0054bb.png)

---

- 애자일(Agile) 개발 방법론
  - 특정 방법론이 아닌 SW를 빠르고 낭비없이 제작키 위해 고객과에 협업에 초점, 설계 변경에 신속히 대응해 요구사항을 수용가능
  - 절차와 도구보다 개인과 소통을 중시, 고객과의 피드백 중시
  - SW가 잘 실행됨에 가치를 두며 SW 배포 시차를 최소화 가능
  - 특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션 변화
  - **종류 : 익스트림프로그래밍(XP), 스크럼(Scrum), 린(Lean), DSDM(Dynamic System Development Method), FDD(Feature Driven Development), Crystal, ASD(Adaptive Software Development), DAD(Disciplined Agile Delivery)**
- Agile 선언문
  - 프로세스나 도구보다 개인과의 소통이 중요 / 완벽한 문서보다 실행되는 SW가 중요 / 계약 협상보다 고객과의 협업이 중요 / 계획 이행보다 변경에 대한 응답이 중요

---

- XP(eXtreme Programming)

  - 1999 Kent Beck 제안, 개발 단계 중 요구사항이 시시각각 변동이 심한 경우 적합한 방법론
  - 요구에 맞는 양질의 SW 신속하게 제공 목표
  - 요구사항을 모두 정의해 놓고 작업을 진행 X, 요구사항이 변경되는 것을 적용하는 방식으로 예측성보다 적응성에 높은 가치 부여
  - 고객의 참여와 개발 과정의 반복을 극대화해 생산성을 향상

- XP 핵심 가치

  - **소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향**
  - **단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제**
  - **피드백(Feedback) : SW개발에서 변화는 불가피, 이러한 변화는 지속적 테스트와 통합, 반복적 결함 수정 등 빠르게 피드백**
  - **용기(Courage) : 고객 요구사항 변화에 능동적으로 대응**
  - **존중(Respect) : 개발 팀원간의 상호 존중**

- XP Process

  - ![image-20230101222311746](https://user-images.githubusercontent.com/107028310/210172801-260eb8b9-9e68-45d4-bdfa-35d04ad9db98.png)
  - User Story : 일종의 요구사항으로 UML의 유즈케이스와 같은 목적으로 생성되나 형식이 없고 고객에 의해 작성
  - Spike : 어려운 요구사항, 잠재적 솔루션을 고려하기 위해 작성하는 간단한 프로그램
  - Release Planning : 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공, 부분/전체 개발 완료 시점에 대한 일정 수립
  - Iteration : 하나의 릴리즈를 세분화 한 단위, 1~3주 단위로 진행, Iteration(반복) 진행 중 새 스토리가 추가될 때 진행 중 반복이나 다음 반복에 추가 가능
  - Acceptance Test : 릴리즈 단위의 개발이 구현되었을 때 진행하는 테스트, 유저 스토리 요구사항을 확인해 고객이 직접 테스트, 오류 발견 시 다음 반복에 추가, 테스트 후 고객 요구사항에 따라 우선순위 변경 가능, 완료 후 다음 반복 진행
  - Small Realease : 릴리즈 단위를 기능별로 세분화 해 고객의 반응을 기능별로 확인 가능, 완제품일 때 고객에 의한 최종 테스트 진행 후 고객에게 제공

- XP의 12가지 실천사항(Practice)

  | 구분                 | 12 실천사항               | 설명                                                         |
  | -------------------- | ------------------------- | :----------------------------------------------------------- |
  | Fine Scale Feedback  | Pair Programming          | 두 사람이 짝이되어 한사람을 코딩, 한사람은 검사 수행 / 코드 책임 공유 / 비형식적인 검토 수행 / 코드 개선을 위한 리팩토링 장려 |
  |                      | Planning Game             | 게임처럼 선수와 규칙, 목표를 두고 기획                       |
  |                      | Test Driven Development   | 실제 코드를 작성하기 전 단위 테스트부터 작성 및 수행, 이를 기반으로 코드 작성 |
  |                      | Whole Team                | 개발 효율을 위해 고객을 프로젝트 팀원으로 상주               |
  | Continuous Process   | Continuous Integration    | 상시 빌드 및 배포를 할 수 있는 상태로 유지                   |
  |                      | Design Improvement        | 기능 변경 없이 중복성, 복잡성 제거 / 커뮤니케이션 향상 / 단순화 / 유연성 등을 위한 재구성을 수행 |
  |                      | Small Releases            | 짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 함 |
  | Shared Understanding | Coding Standards          | 소스 코드 작성 포맷과 규칙들을 표준화 된 관례에 따라 작성    |
  |                      | Collective Code Ownership | 시스템에 있는 소스 코드는 팀의 모든 프로그래머가 누구든 언제라도 수정 |
  |                      | Simple Design             | 가능한 가장 간결한 디자인 상태를 유지                        |
  |                      | System Metaphor           | 최종 개발되어야 할 시스템의 구조를 기술                      |
  | Programmer Welfare   | Sustatinable Pace         | 일주일에 40시간 이상 작업 금지, 2주 연속 오버타임 금지       |

- 효과적인 프로젝트 관리를 위한 3대 요소

  - **사람(People) : 인적자원 / 문제(Problem) : 문제 인식 / 프로세스(Process) : 작업 계획**	[3P라 총칭]

- 정형 기술 검토 지침 사항

  - 의제와 그 범위를 유지 / 참가자 수 제한 / 체크 리스트 작성 및 자원, 시간 일정 할당 / 개발자가 아닌 제품의 검토에 집중 / 논쟁과 반박 제한 / 검토 과정과 결과를 재검토

---

### 4. SCRUM

- SCRUM 개념과 특징
  - 요구사항 변경에 신속하게 대처할 수 있도록 반복적이고 점진적인 소규모 팀원 간 활발한 소통과 협동심이 필요한 팀 중심의 SW 개발 방법론
  - 신속하게 반복적으로 실제 작동하는 SW 제공
  - 개발자들의 팀 구성과 각 구성원의 역할, 일정 결과 물 및 그 외 규칙을 정하는 것
  - 기능 개선점에 우선순위 부여, 개발 주기 동안 실제 동작 가능한 결과 제공
  - 개발 주기마다 적용된 기능이나 개선점의 리스트 제공
  - 커뮤니케이션을 위해 개방된 공간에서 개발, 매일 15분 정도의 회의
  - 팀원 스스토 팀을 구성 (Self Organizing)
  - 개발 작업에 관한 모든 것을 팀원 스스로 해결해야 함 (Cross Functional)
  
- SCRUM 기본 원리

  - 기능 협업을 기준으로 배치된 팀은 스프린트 단위로 SW 개발
  - 스프린트는 고정된 30일의 반복으로 시행 작업은 고정
  - 요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 함
  - 정해진 시간 지키기, 작업 제품 백로그에 기록
  - 일일 스탠드 업 미팅, 일일 스크럼을 통한 기본 정보 교환

- SCRUM팀의 역할

  - ![image](https://user-images.githubusercontent.com/107028310/210216818-2a805aff-1afa-4c54-8dba-83f710d02e69.png)

    | 담당자                      | 역할                                                         |
    | --------------------------- | ------------------------------------------------------------ |
    | 제품 책임자 (Product Owner) | 개발 목표에 이해도가 높은 의뢰자, 사용자가 담당 / 요구사항을 파악해 기능 목록(Product Backlog) 작성 / 테스트 수행 및 우선순위 갱신 / 스프린트 계획 수립까지만 임무를 수행 / 스트린트 시작 시 팀 운영에 관여 X |
    | 스크럼 마스터               | 업무 배분만 하고 일은 강요 X / 팀 스스로 조직하고 관리하도록 지원 / 개발 장애 요소 제거 / 스크럼 원칙 가치 지원 |
    | 스크럼 팀                   | 제품 책임자, 스크럼 마스터를 제외한 팀원이 해당, 팀원은 5~9명 / 기능을 작업단위로 분류, 스토리로 도출 구현 / 일정을 추정해 책임자에게 전달 / 결과물을 책임자에게 시연 / 매일 스크럼 회의 |


---

- SCRUM 과정
  - Product Backlog : 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록 / 지속적 업데이트 / 릴리즈 계획 수립
  - Sprint : 작은 단위의 개발 업무를 단기간에 전력 질주하여 개발 / 반복 주기마다 진척도 보고
  - Spring Planning Meeting : Product Backlog 에서 진행할 목록을 선택 / 단기 일정 수립, 요구사항을 Task 단위로 나눔 / Sprint Backlog 작성, 결과물 모습 결정 / SCRUM Master 에게 보고해 이해관계자로부터 수행에 필요한 요구사항 지원
  - Daily SCRUM Meeting : 매일 약속된 시간에 짧게 서서 진행 점검 / 완료된 작업항목을 스프린트 현황판에 갱신 / 스크럼 마스터는 방해요소를 찾아 제거 후 작업 시간을 **소멸차트(Burn down Chart)**에 기록
  - Finished Work : 모든 스프린트 주기 완료 시 제품 기능 목록(Product Backlog)의 개발 목표물 완성
  - Sprint Review : 개발자와 사용자 같이 참석 / 반복주기 종료 시 생성된 제품에 대해 검토 / 개선 사항에 대해 제품 책임자는 피드백을 정리 후 백로그 작성
  - Sprint Retrospective : 개선점이 없는지 살펴보고 문제점 기록 정도로 진행 / 강점을 찾아 팀 능력 극대화 / 추정속도와 개발속도 비교해 차이 원인 분석

---

### 5. 현행 시스템 분석

- 현행 시스템 분석의 정의와 목적
  - 현행 시스템이 어떤 하위 시스템으로 구성되어 있는지 파악하는 절차
  - 현행 시스템의 제공 기능과 타 시스템과의 정보 교환 분석을 파악
  - 기술 요소와 SW, HW 파악
  - 목적 : 개발 시스템의 개발 범위 확인 및 이행 방향성 설정

- 현행 시스템 파악 절차
  - 1단계 : 시스템 구성 파악 - 시스템 기능 파악 - 시스템 인터페이스 현황 파악
  - 2단계 : 아키텍처 파악 - SW구성 파악
  - 3단계 : 시스템 HW 현황 파악 - 네트워크 구성 파악

- 시스템 아키텍처
  - 시스템 내 상위 시스템과 하위 시스템이 어떤 관계로 상호작용하는지 각각의 동작 원리와 구성을 표현
  - 단위 업무 시스템별로 아키텍처가 다른 경우 핵심 기간 업무 처리 시스템을 기준
  - 시스템의 전체 구조, 행위 그리고 행위 원리를 나타내며 시스템이 어떻게 작동하는지 설명
  - 시스템의 목적 달성을 위해 각 컴포넌트를 식별하고 컴포넌트의 상호작용을 통해 어떻게 정보 교환이 발생하는지 설명
  - 시스템 아키텍처 <-> SW 아키텍처 -> SW 상세설계


---

- 시스템 구성 파악

  - 조직 내 주요업무를 기간 업무와 지원업무로 구분해 기술

  - 모든 단위 업무를 파악, 시스템 내 명칭, 기능 등 주요 기능 명시

  - 예시

    | 구분     | 시스템명    | 시스템 내용                                       |
    | -------- | ----------- | ------------------------------------------------- |
    | 기간업무 | 단위 A 업무 | 기간 단위 업무 A 처리를 위한 A1,A2 등의 기능 제공 |
    |          | 단위 B 업무 | 기간 단위 업무 B 처리를 위한 B1,B2 등의 기능 제공 |
    | 지원업무 | 단위 C 업무 | 지원 업무 C 처리를 위한 C1, C2 등의 기능 제공     |

- 시스템 기능 파악

  - 단위 업무 시스템이 현재 제공하는 기능을 주요, 하부 기능으로 구분해 계층형으로 표시
  - 예시

  | 시스템명           | 기능 L1 | 기능 L2      | 기능 L3      |
  | ------------------ | ------- | ------------ | ------------ |
  | A 단위 업무 시스템 | 기능1   | 하부 기능 11 | 세부기능 111 |
  |                    |         |              | 세부기능 112 |
  |                    |         | 하부기능 12  | 세부기능 121 |
  |                    |         |              | 세부기능 122 |
  |                    | 기능2   | 하부기능 21  | 세부기능 211 |
  |                    |         |              | 세부기능 212 |

- 인터페이스 현황 파악

  - 현행 시스템의 단위 업무 시스템이 타 단위 업무 시스템과 주고받는 데이터의 연계 유형, 데이터 형식과 종류, 프로토콜 및 주기 등을 명시

  - 데이터형식 (예 : XML, 고정 Format, 가변 Format) / 통신 규약 (예 : TCP/IP, X.25) / 연계 유형 (예 : EAI, FEP)

  - 예시

    | 송신시스템         | 수신시스템         | 연동데이터 | 연동형식 | 통식규약 | 연계유형 | 주기  |
    | ------------------ | ------------------ | ---------- | -------- | -------- | -------- | ----- |
    | A 단위 업무 시스템 | 대외 기관 시스템 C | 연체정보   | XML      | TCP / IP | EAI      | 1시간 |
    | B 단위 업무 시스템 | 대외 기관 시스템 D | 신용정보   | XML      | X.25     | FEP      | 수시  |

- EAI(Enterprise Application Integration, 기업 애플리케이션 통합)

  - 기업 내 컴퓨터 애플리케이션들을 현대화하고, 통합하고, 조정하는 것을 목표로 세운 계획, 방법 및 도구를 의미

- **FEP(Front-End Processor, 전위 처리기)**

  - 입력 데이터를 프로세서가 처리하기 전에 미리 처리해 처리시간을 줄여주는 프로그램이나 HW
  - 여러 통신 라인을 중앙 컴퓨터에 연결하고 터미널의 메시지가 보낼 상태로 있는지 받을 상태로 있는지 검색, 통신라인의 에러 검출


---

- 소프트웨어 구성 파악
  - 시스템 내의 단위 업무 시스템의 업무 처리용 SW의 품명, 용도, 라이선스 적용 방식, 라이선스 수를 명시
  - 시스템 구축 시 많은 예산 비중을 차지 하므로 라이선스 적용 방식과 보유한 라이선스 수량 파악이 중요
  - 라이선스 적용 방식 단위 : 사이트, 서버, 프로세서, 코어, 사용자 수

- 하드웨어 구성 파악
  - 각 단위 업무 시스템의 서버 위치 및 주요 사양, 수량, 이중화 여부를 파악
  - 서버 사양 : CPU 처리 속도, 메모리 크기, 하드 디스크의 용량
  - 서버 이중화 : 장애 시 서비스의 유지를 위하여 운영
  - 기간 업무의 장애 대응 정책에 따라 필요 여부가 달라짐
  - 시스템에 이중화가 적용되어 있다면 대부분 목표 시스템도 이중화가 요구되므로 그에 따른 기술 난이도, 비용 증가 가능성 파악

- 네트워크 구성 파악
  - 현행 업무 처리 시스템의 네트워크 구성 형태를 그림으로 표현
  - 장애 발생 시 추적 및 대응의 다양한 용도
  - 서버의 위치, 서버 간 연결 방식 등을 파악
  - 물리적인 위치 관계, 조직 내 보안 취약성 분석 및 대응 방안 파악

- 개발 기술 환경 분석
  - 개발 대상 시스템의 플랫폼, OS, DBMS, Middle Ware 등을 분석


---

- 플랫폼
  - 응용 SW + (HW + 시스템 SW)
  - 다양한 애플리케이션이 작동하는 기본이 되는 운영체제 SW
  - 종류 : JAVA 플랫폼, .NET 플랫폼, iOS, Android, Windows
  - 기능 : 개발/운영/유지보수 비용의 감소, 생산성 향상, 동일 플랫폼 간의 네트워크 효과

- 플랫폼 성능 특성 분석
  - 현행 시스템의 사용자가 요구사항을 통해 시스템 성능상의 문제를 요구할 경우 플랫폼 성능 분석을 통해 사용자가 느끼는 속도를 파악하고 개선 방향 제시
  - 특성 분석 항목 : 응답시간 (Response Time), 가용성(Availability), 사용률(Utilization)

- 플랫폼 성능 특성 분석 방법
  - **기능 테스트(Perfomance Test) : 현재 시스템의 플랫폼을 평가할 수 있는 기능 테스트를 수행**
  - **사용자 인터뷰 : 사용자를 대상으로 현행 플랫폼 기능의 불편함을 인터뷰**
  - **문서 점검 : 플랫폼과 유사한 플랫폼의 기능 자료를 분석**


---

- OS(Operating System, 운영체제) 정의 및 기능
  - HW, SW 자원 관리 및 공통 서비스 제공, 사용자와의 인터페이스를 제공
  - 종류 : Windows, Android, iOS, UNIX, LINUX, Mac OS 등

- 현행 시스템의 OS 분석 항목 및 고려사항
  - **분석 항목 : 현재 정보 시스템의 OS 종류와 버전, 패치 일자, 백업 주기 분석**
  - **고려사항 : 가용성, 성능, 기술지원, 주변기기, 구축 비용(TCO[^3])**
  - **메모리 누수 : 실행 SW가 정상 종료되지 않고 남아 있는 증상**


[^3]: Total Cost of Ownership : 일정 기간 자산 획득에 필요한 직간접적인 총비용으로 HW, SW 구매비용, 운영 교육, 기술지원, 유지보수, 손실, 에너지비용

- 오픈소스 라이선스 종류
  - **소스 코드가 공개되어 누구나 특별한 제한 없이 소스 사용 가능하며 대표적으로 LINUX가 있다**
  - **GNU(GNU's Not Unix) : 컴퓨터 프로그램을 물론 모든 관련 정보를 돈 주고 구매하는 것에 반대하는 기본 이념. 예) LINUX**
  - **GNU GPLv1(General Public License) : 소스 코드를 공개 하지 않으면서 바이너리만 배포하는 것을 금지, 사용할 수 있는 쉬운 소스 코드를 같이 배포**
  - **BSD(Berkeley Software Distribution) : 아무나 개작, 수정한 것을 제한 없이 배포 가능하다. 단, 수정본의 재배포는 의무X. 미공개 상용 SW에서도 사용**
  - **Apache 2.0 : Apache 재단 소유의 SW 적용을 위해 제공하는 라이선스. 소스 코드 수정 배포 시 Apache 2.0 포함. 예) Android, HADOOP[^4]**

[^4]: 다수의 저렴한 컴퓨터를 하나처럼 묶어 대량 데이터(Big Data)를 처리하는 기술

---

- DBMS(DataBase Management System)

  - **종속성과 중복성의 문제**를 해결하기 위해서 제안된 데이터베이스 시스템
  - 응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리
  - 데이터베이스의 구성, 접근 방법, 관리 유지에 대한 모든 책임
  - 종류 : Oracle, IBM DB2, Microsoft SQL Server, MySQL, SQ Lite, MongeDB, Redis

- 현행 시스템 DBMS 분석

  - DBMS 종류, 구성 방식, 저장 용량, 백업 주기, 제작사의 유지보수 여부 가능성을 분석
  - 테이블 수량, 데이터 증가 추이, 백업 방식 등을 분석
  - 논리/물리 테이블의 구조도를 파악, 각 테이블의 정규화 정도, 조인 난이도, 각종 프로시저, 트리거 등을 분석

- DBMS 분석 시 고려사항

  - | 구분        | 설명                                                         |
    | ----------- | ------------------------------------------------------------ |
    | 가용성      | 장시간 운영 시 장애 발생 가능성, 패치 설치를 위한 재 기동 시간과 이중화 및 복제 지원, 백업 및 복구 편의성 등을 고려 |
    | 성능        | 대규모 데이터 처리 성능(불할 테이블의 지원 여부), 대량 거래 처리 성능 및 다양한 튜닝 옵션 지원, 비용 기반 최적화 지원 및 설정의 최소화 등을 고려 |
    | 기술지원    | 제조업체의 안정적인 기술 지원, 같은 DBMS 사용자들 간의 정보 공유 여부와 오픈소스 여부 등을 고려 |
    | 상호 호환성 | 설치 가능한 운영체제 종류를 파악하여 다양한 운영체제에서 지원되는지 확인. JDBC, ODBC 등 상호 호환성이 좋은 제품 선택 |
    | 구축 비용   | 라이선스 정책 및 비용, 유지 또는 관리 비용, 총 소유 비용(TCO)을 고려 |


---

### 6. 요구사항 개발

- 요구공학(Requirements Engineering)
  - SW 개발 시 사용자 요구가 정확히 반영된 시스템 개발을 위해 요구를 추출, 분석, 명세, 검증, 관리하는 구조화된 활동 집합
  - 요구사항을 정의, 문서화, 관리하는 프로세스
  - 효과적인 의사소통을 통해 공통 이해를 설정하고 불필요한 비용 절감, 요구사항 변경 추적 가능
  - 분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용
  - 자료 흐름도, 자료 사전 등이 효과적으로 이요될 수 있으며, 구체적 명세를 위해 소단위 명세서(Mini-Spec)가 활용
- 요구공학의 목적
  - SW 개발 시 이해관계자 사이의 원활한 의사소통 수단 제공
  - 요구사항 누락방지, 상호 이해 오류 등의 제거로 경제성 제공
  - 요구사항 변경 이력 관리를 통해 개발 비용 및 시간 절약
  - 비용과 일정에 대한 제약 설정과 타당성 조사, 요구사항 정의 문서화 등을 수행

- 요구사항 베이스라인(BaseLine, 기준선)
  - 이해 당사자 간의 명시적 합의 내용이며 프로젝트 목표 달성 여부를 확인하는 기준
  - 요구사항을 조기에 명확히 확정, 추후 발생 가능한 변경사항을 체계적으로 관리하기 위한 기준
- 요구공학(개발) 프로세스
  - 요구사항을 명확히 분석해 검증하는 진행순서
  - 개발 대상에 대한 요구사항을 체계적으로 도출
  - 도출된 요구사항 분석해 결과를 명세서에 정리
  - 경제성, 기술성, 적법성, 대안성 등 타당성 조사가 선행
- SWEBOK[^5]에 따른 요구사항 개발 프로세스
  - 도출(Elicitation) > 분석(Analysis) > 명세(Specification) > 확인(Validation)

[^5]: SWEBOK(Software Engineering Body of Knowledge, 소프트웨어 공학 지식 체계) : 국제 표준화 기구의 정보 기술 분야인 ISO/IEC 에서 의견을 모아 집필 발간하는 표준화 체계문서

- 요구사항 도출(Requirement Elicitation)

  - SW가 해결해야 할 문제를 이해하는 첫 단계
  - 현재 상태 파악, 문제 정의 후 문제 해결과 목표를 정확히 도출하는 단계
  - 요구사항의 위치와 수집 방법과 관련
  - 이해관계자(Stakeholder)가 식별되며, 개발팀과 고객사이의 관계가 만들어지는 단계이며 다양하고 효율적인 의사소통 중요
  - 요구사항 도출 기법 : 고객의 발표, 문서 조사, 설문, 업무 절차 및 양식 조사, 브레인스토밍, 워크숍, 인터뷰, 관찰 및 모델의 프로토타이핑, Use Case, 벤치마킹, BPR(업무 재설계), RFP(제안 요청서)

- 요구사항 분석(Requirement Analysis)

  - SW가 환경과 어떻게 상호작용하는지 이해, 사용자의 요구사항을 걸러 내기 위한 과정을 통해 요구사항을 도출, 요구사항 정의를 문서화 하는 과정
  - 도출할 사항을 분석, SW개발 범위를 파악하고 개발 비용, 일정에 대한 제약 설정과 타당성 조사를 수행
  - 요구사항 간 상충하는 것을 해결, SW의 범위(비용과 일정)를 파악하고, 타당성 조사 시행
  - 요구사항 기술 시 요구사항 확인, 요구사항 구현의 검증, 비용 추정 등의 작업이 가능하도록 충분하고 정확하게 기술
  - 요구분석을 위한 기법 : 사용자 의경 청취, 사용자 인터뷰, 현재 사용중인 각종 문서 분석과 중재, 관찰 및 모델 작성 기술, 설문조사를 통한 의견 수렴

- 요구사항 분석 수행 단계

  - 문제인식 : 인터뷰, 설문조사 등 도구를 활용해 요구사항을 파악
  - 전개  : 파악한 문제를 자세히 조사
  - 평가와 종합 : 요구들을 다이어그램이나 자동화 도구를 이용해 종합
  - 검토 : 요구분석 작업의 내용을 검토, 재정리하는 과정
  - 문서화 : 욕사항 분석 내용을 문서로 만드는 단계

- 요구사항 분류

  - 기술 내용에 따른 분류 : 기능 요구사항, 비기능 요구사항
  - 기술 관점 및 대상에 따른 분류 : 시스템 요구사항, 사용자 요구사항

- 요구사항 분류 기준

  - 기능 요구사항, 비기능 요구사항을 구분, 우선순위 여부 확인
  - 요구사항이 하나 시아의 고수준 요구사항으로부터 유도된 것인지 확인
  - 이해관계자나 다른 원천으로부터 직접 발생한 것인지 확인
  - 요구사항이 제품에 관한 것인지 프로세스에 관한 것인지 확인하고 SW에 미치는 영향의 범위 확인
  - 요구사항이 SW 생명주기 동안 변경이 발생하는지 확인

- 기능적 요구사항 vs 비기능적 요구사항

  - | 기능적 요구사항                                        | 비기능적 요구사항                                            |
    | ------------------------------------------------------ | ------------------------------------------------------------ |
    | 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항 | 시스템 구축에 대한 성능, 보안, 품질, 안정성 등으로 실제 수행에 보조적인 요구사항 |

- 요구사항 명세(Requirement Specification)

  - 시스템의 정의, 시스템의 요구사항, SW 요구사항을 작성
  - 체계적으로 검토, 평가, 승인될 수 있도록 문서로 만드는 것을 의미
  - 기능요구사항은 빠지는 부분 없이 명확하게 기술
  - 설계 과정의 오류사항을 추적이 가능해야 함
  - 비기능 요구사항은 필요한것만 명확하게 기술
  - 개발자가 효과적으로 설계할 수 있고 사용자가 쉽게 이해할 수 있도록 함

- 요구사항 명세 기법

  - | 구분 | 정형 명세                                                    | 비정형 명세                                                  |
    | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 기법 | 수학적 기반/모델링 기반                                      | 상태/기능/객체 중심 명세기법으로 자연어 기반                 |
    | 종류 | Z, VDM<br />Petri-Net(모형 기반)<br />LOTOS(대수적 방법)<br />CSP, CCS | FSM(Finite State Machine)<br />Decision Table, ER모델링<br />State Charts(SADT)<br />Use Case<br />사용자 기반 모델링 |
    | 장점 | 시스템 요구 특성을 정확하고 명세가 간결하게 명세 가능, 명세/구현의 일치 | 명세 작성 이해 용이, 의사전달 방법 다양성                    |
    | 단점 | 낮은 이해도, 이해관계자의 부담 가중                          | 불충분한 명세 기능, 모호성                                   |

- 요구사항 명세 속성

  - 정확성 : 요구사항은 정확해야 한다
  - 명확성 : 단 한 가지로만 해설되어야 한다
  - 완전성 : 모든 것이 표현(기능 + 비기능) 가능해야 한다.
  - 일관성 : 요구사항 간 충돌이 없어야 한다.
  - 수정 용이성 : 요구사항 변경이 가능해야 한다.
  - 추적성 : RFP, 제안서를 통해 추적 가능해야 한다.

- 요구사항 확인(Requirement Validation)

  - 요구사항 분석 단계를 거쳐 문서로 만들어진 내용을 확인하고 검증하는 단계
  - 일반적으로 요구사항 관리 도구를 이용해 이해관계자들이 문서를 검토, 요구사항 정의 문서들에 대해 형상 관리
  - 회사의 표준에 적합하고 이해할 수 있고, 일관성이 있고 완전한지 검증
  - 요구 분석가가 요구사항을 이해했는지 확인(Validation)이 필요
  - 리소스가 요구사항에 할당되기 전에 문제를 파악하기 위해 검증 수행 (표준에 적합한지, 이해 가능한지, 일관성 있는지, 완전한지)
  - 요구사항 관리 도구의 필요성 : 요구사항 변경으로 인한 비용 편익 분석, 요구사항 변경의 추적, 요구사항 변경에 따른 영향 평가

- 형상 관리(Configuration Management)

  - 애플리케이션 개발 단계에서 도출되는 프로그램, 문서, 데이터 등의 모든 자료를 형상 단위라고 하며, 이러한 자료의 변경을 관리함으로써 애플리케이션 버전 관리 등을 하는 활동

- 요구사항 할당(Requirement Allocation)

  - 요구사항을 만족시키기 위한 아키텍처 구성 요소를 식별하는 활동
  - 식별된 타 구성 요소와 상호작용 여부 분석을 통하여 추가 요구사항 발견 가능

- 정형 분석(Formal Analysis)

  - 구문(Syntax)과 형식적으로 정의된 의미(Semantics)를 ㅈ닌 언어로 요구사항을  표현
  - 명확하게 표현해 오해를 최소화
  - 요구사항 분석의 마지막 단계에서 이루어짐

---

- 요구사항 확인 기법의 종류

  - 프로토타이핑(Prototyping), 모델 검증(Model Verification), 요구사항 검토(Requirement Reviews), 인수 테스트(Acceptance Test)

- 프로토타이핑(Prototyping)

  - 도출된 요구사항을 토대로 프로토타입을 제작해 대상 시스템과 비교하며 개발 중 도추로디는 추가 요구사항을 지속해서 재작성하는 과정

  - 새 요구사항을 도출하기 위한 수단

  - SW 엔지니어 관점에서 요구사항을 확인하기 위한 수단으로 많이 사용되고 실제 구현 전에 잘못된 요구사항을 적용하는 자원 낭비 방지

  - 절차 : 요구사항 분석 단계 > 프로토타입 설계 단계 > 프로토타입 개발 단계 > 고객의 평가 단계 > 프로토타입 정제 단계 > 완제품 생산 단계

  - | 장점                                                         | 단점                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 분석가의 가정을 파악하고 잘못되었을 시 유용한 피드백 제공<br />문서나 그래픽 모델보다 프로토타입으로 이해하기가 쉬움<br />요구사항의 가변성이 프로토타이핑 이후 급격히 감소<br />빠르게 제작 가능하며 반복 제작을 통해 발전된 결과 | 사용자 관심이 핵심 기능에서 멀어질 수 있으며 디자인에 집중 가능<br />프로토타입 수행 비용 발생<br />전체 범위 중 일부 대상 범위만 제작 시 사용성이 과대 평가 가능 |

- 모델검증(Model Certification)

  - 분석 단계에서 개발된 모델의 품질 검증
  - 정적 분석(Static Aanalysis) : 객체 모델에서 객체들 사이에 존재하는 Communication Path(의사소통 경로)를 검증하기 위해 사용, 명세의 일관성과 정확성을 확인 분석하는 도구
  - 동적 분석(Dynamic Analysis) : 직접 실행을 통하여 모델을 검증하는 방식

- 인수 테스트(Acceptance Tests)

  - 최종 제품이 설계 시 제시한 요구사항을 만족하는 지 확인하는 단계
  - 인수 시 각 요구사항의 확인 절차 계획
  - 종류 : 계약 인수 테스트, 규정 인수 테스트, 알파 검사, 베타 검사, 사용자 인수 테스트, 운영 인수 테스트

---

### 07. UML

- 개념 모델링
  - 요구사항을 이해하기 쉽도록 실 세계의 상황을 단순화해 개념적으로 표현한 것이 모델, 표현된 모델을 생성해 나가는 과정을 개념 모델링이라고 함
  - 모델은 문제가 발생하는 상황에 대한 이해를 증진하고 해결책을 설명하므로 SW 요구사항 분석의 핵심이라 할 수 있다.
  - 개발 대상 도메인의 엔티티(Entity)들과 그들의 관계 및 종속성을 반영
  - 요구사항별로 관점이 다르므로 개념 모델도 다양하게 표현
  - 대부분 UML(Unified Modeling Language)을 사용
  - 종류 : Use Case Diagram, Data Flow Model, State Model, Goal-Based Model, User Interactions, Object Model, Data Model

---

- UML (Unified Modeling Lanugage)

  - 객체지향 SW 개발 과정에서 시스템 분석, 설계, 구현 등의 산출물을 명세, 시각, 문서화 할 때 사용하는 모델링 기술과 방법론을 통합하여 만든 모델링 언어
  - Rumbaugh의 OMT 방법론과 Booch의 Booch 방법론, Jacobson의 OOSE 방법론을 통합하여 만든 모델링 개념의 공통 집합으로 객체지향 분석 및 설계 방법론의 표준 지정을 목표로 제안된 모델링 언어
  - OMG(Object Management Group)에서 표준화 공고 후 IBM, HP, Microsoft, Oracle 등이 참여하여 1997.1 버전 1.0 릴리즈

- 럼바우(Rumbaugh) 객체지향 분석기법

  - SW 구성요소를 그래픽으로 모형화
  - 객체 모델링 기법이라고도 함
  - 객체 모델링 : 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내 속성과 연산 식별 및 객체들 간의 관계를 규정, 객체를 다이어그램으로 표시
  - 동적 모델링 : 제어 흐름, 상호작용, 동작 순서 등의 상태를 시간 흐름에 따라 상태 다이어그램으로 표시
  - 기능 모델링 : 여러 프로세스 간의 자료 흐름을 표시한다. 어떤 데이터를 입력해 어떤 결과를 가져올 수 있을지를 표현

- UML의 특성

  - 비주얼화 : SW 구성 요소 간의 관계 및 상호작용을 시각화
  - 문서화 : SW 생명주기의 중요한 작업을 추적하고 문서화 가능. 개발 프로세스 및 언어와 무관하게 개발자 간의 의사소통 도구 제공
  - 명세화 : 분석, 설계, 구현의 완벽한 모델 제공. 분석 단계-기능 모델, 설계 단계-동작 수준 모델, 구현 단계-상호작용 모델 수준으로 명세화 할 수 있음. 단순 표기가 아닌 구현에 필요한 개발적 요소 및 기능에 대한 명세 제공
  - 구축 : 객체지향 언어와 호환되는 프로그래밍 언어는 아니지만 모델이 객체지향 언어로 매핑될 수 있음

- UML 소프트웨어에 대한 관점

  - 기능적 관점 : 사용자 측면에서 본 SW의 기능 표시, 사용 사례 모델링이라고도 하며 요구 분석 단계에서 사용. UML에서는 Use Case Diagram사용
  - 정적 관점 : SW 내부의 구성 요소 사이의 구조적 관계를 나타낸다. 객체, 속성, 연관 관계, 오퍼레이션의 시스템 구조를 나타내며, UML에서는 Class Diagram 사용 (예 : 클래스 사이의 관계, 클래스 구성과 패키지 사이의 관계)
  - 동적 관점 : 시스템의 내부 동작, UML에서는 Sequence Diagram(회귀 메세지, 제어블록 등으로 구성된 순차적 다이어그램), State Diagram, Activity Diagram을 사용

- UML의 기본구성

  - | 구성                | 설명                                                         |
    | ------------------- | ------------------------------------------------------------ |
    | 사용(Things)        | 객체지향 모델을 구성하는 기본 요소<br />객체 간의 관계 형성 대상 |
    | 관계(Relationship)  | 객체 간의 연관성을 표현<br />종류 : 연관, 집합, 포함, 일반화, 의존, 실체화 |
    | 다이어그램(Diagram) | 객체의 관계를 도식화<br />다양한 관점에서 의사소통 할 수 있도록 View 제공<br />정적모델 : 구조 다이어그램<br />동적 모델 : 행위 다이어그램 |

- 스테레오 타입

  - UML에서 제공하는 기본 요소 외에 추가적인 확장 요소 표현시 사용
  - UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호는 길러멧(Guillemet) <<>> 이며, 길러멧 안에 확장 요소를 적는다

- UML 접근제어자

  - | 접근제어자 | 표기 | 설명                                                         |
    | ---------- | ---- | ------------------------------------------------------------ |
    | public     | +    | 어떤 클래스의 객체에서든 접근 가능                           |
    | private    | =    | 해당 클래스로 생성된 객체만 접근 가능                        |
    | protected  | #    | 해당 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능 |
    | package    | ~    | 동일 패키이에 있는 클래스의 객체들만 접근 가능               |

- 연관 관계 다중성 표현

  - | 표기        | 의미                        |
    | ----------- | --------------------------- |
    | 1           | 1 개체 연결                 |
    | * 또는 0..* | 0이거나 그 이상의 객체 연결 |
    | 1..*        | 1이거나 1 이상 객체 연결    |
    | 0..1        | 0이거나 1 객체 연결         |
    | 1, 3, 4     | 1이거나 3이거나 6 객체 연결 |
    | n           | n개 객체 연결               |
    | n..*        | n이거나 n개 이상 객체 연결  |

---

- 구조적 다이어그램(Structured Diagram)

  - 정적이고 구조 표현을 위한 다이어그램

  - | 다이어그램 유형                                     | 목적                                                         |
    | --------------------------------------------------- | ------------------------------------------------------------ |
    | 클래스 다이어그램(Class Diagram)                    | 시스템 내 클래스의 정적 구조를 표현하고 시스템을 구성하는 클래스들 사이의 관계 표현 |
    | 객체 다이어그램(Object Diagram)                     | 객체 정보를 보여줌                                           |
    | 복합체 구조 다이어그램(Composite Structure Diagram) | 복합 고주의 클래스와 컴포넌트 내부구조를 표현                |
    | 배치 다이어그램(Deployment Diagram)                 | SW, HW, 네트워크를 포함한 실행 시스템의 물리 구조를 표현     |
    | 컴포넌트 다이어그램(Component Diagram)              | 컴포넌트 구조 사이의 관계를 표현                             |
    | 패키지 다이어그램(Package Diagram)                  | 클래스나 유스케이스 등을 포함한 여러 모델 요소들을 그룹화해 패키지를 구성하고 패키지들 사이의 관계를 표현 |

- 행위 다이어그램(Behavior Diagram)

  - 동적이고 순차적인 표현을 위한 다이어그램

  - 종류 : Use Case Diagram, Activity Diagram, Collaboration Diagram, State Diagram, Interaction Diagram(Sequence Diagram, Communication Diagram, Interaction Overview Diagram, Timing Diagram)

  - | 다이어그램 유형       |                              | 목적                                                         |
    | --------------------- | ---------------------------- | ------------------------------------------------------------ |
    | Use Case Diagram      |                              | 사용자 관점에서 시스템 행위를 표현                           |
    | Activity Diagram      |                              | 업무 처리 과정이나 연산이 수행되는 과정을 표현               |
    | State Machine Diagram |                              | 객체의 생명주기를 표현, 동적 행위를 모델링하지만 특정 객체만을 다룸<br />예 : 실시간 임베디드 시스템, 게임, 프로토콜 설계에 이용 |
    | Collaboration Diagram |                              | Sqeunce Diagram과 같으며 모델링 공간에 제약이 없어 구조적인 면 중시 |
    | Interaction Diagram   | Sequence Diagram             | 시스템 동작을 정형화, 객체의 메시지 교환을 쉽게 표현하고 시간에 따른 발생 순서 강조<br />요소 : 생명선(Life Line), 통로(Gate), 상호작용(Interaction Fragment), 발생(Occurrence), 실행(Execution), 상태 불변(State Invariant), 메시지(Messages), 활성(Activations), 객체(Entity), Actor |
    |                       | Interaction Overview Diagram | 여러 상호작용 다이어그램 사이의 제어 흐름 표현               |
    |                       | Communication Diagram        | 객체 사이의 관계를 중심으로 상호작용 표현                    |
    |                       | Timing Diagram               | 객체 상태 변화와 시간 제약을 명시적으로 표현                 |

---

- Class Diagram

  - 시스템을 구성하는 객체 간의 관계를 추상화한 모델을 논리적 구조로 표현
  - 객체지향 개발에서 공통으로 사용
  - 분석, 설계, 구현 단계 전반에 지속해서 사용
  - ![image](https://user-images.githubusercontent.com/107028310/210355891-bc474320-4b85-4568-9127-a9d0c6c13686.png)
  - 클래스명 : Rectangle / 속성 : length, width / 속성 타입 : double / 오퍼레이션 : +Rectangle(), +setDimension, ..., +print / 오퍼레이션 리턴 타입 : void, double / 오퍼레이션 매개 변수 : double

- UML 관계 표현

  - | 구성             | 표시                                                         | 설명                                                         |
    | ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 단방향 연관 관계 | ![image](https://user-images.githubusercontent.com/107028310/210357505-c3cc2020-13da-488c-ba05-341835bac1db.png) | 한쪽은 알지만 반대쪽은 상대방의 존재를 모름                  |
    | 양방향 연관 관계 | ![image](https://user-images.githubusercontent.com/107028310/210357647-610fd7a8-bb12-416e-a863-430f3705f3e1.png) | 양쪽 클래스 객체들이 서로의 존재를 인식                      |
    | 의존 관계        | ![image](https://user-images.githubusercontent.com/107028310/210357826-35535f5c-bcda-4401-9b62-8c1e6713bcdf.png) | 연관 관계는 같지만 메소드를 사용할 때와 같이 매우 짧은 시간만 유지 |
    | 일반화 관계      | ![image](https://user-images.githubusercontent.com/107028310/210357977-2c052174-2020-4cae-bda1-161473a7c423.png) | 객체지향에서 상속 관계(IS-A)를 표현하며, 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 사용 |
    | 집합/포함 관계   | ![image](https://user-images.githubusercontent.com/107028310/210358157-7fdf01a0-3508-447c-b234-b05baca69b95.png) | 클래스 사이 전체나 부분이 같은 관계                          |
    |                  | ![image](https://user-images.githubusercontent.com/107028310/210358190-2a424fdd-ee23-4feb-938c-e8db209e2000.png) | 전체/부분 객체 라이프타임 의존적(전체 객체 삭제 > 부분 객체 삭제) |
    | 실체화 관계      | ![image](https://user-images.githubusercontent.com/107028310/210358239-11e1bbe9-b1ea-4278-a276-033c73036392.png) | 책임 집합 인터페이스와 실제로 실현한 클래스들의 사이         |

- UML 연관 관계(Association Relation)

  - 한 사물의 객체가 다른 사물의 객체와 연결된 것을 표현
  - 두 클래스가 서로 연관이 있다면 A, B 객체를 서로 참조 할 수 있음을 표현
  - ![image](https://user-images.githubusercontent.com/107028310/210358471-5f6126f6-bec1-401b-884a-22abe558443a.png)

- UML 의존 관계(Dependency Relation)

  - 연관 관계와 같지만 메소드를 사용할 때와 같이 매우 짧은 시간만 유지
  - 영향을 주는 객체(User)에서 영향을 받는 객체 방향으로 점선 화살표 연결
  - ![image](https://user-images.githubusercontent.com/107028310/210358627-8870b73f-146b-4146-bf6c-5d7eed0cea1d.png)

- UML 일반화 관계(Generalization Relation)

  - 객체지향에서 상속관계를 표현
  - 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 사용
  - ![image](https://user-images.githubusercontent.com/107028310/210359605-a4db32f5-c664-4937-adce-28a3dcb85a35.png)

- UML 집합 관계(Aggregation Relation)

  - A 객체가 B 객체에 포함된 관계
  - '부분'을 나타내는 객체를 다른 객체와 공유 가능
  - '전체' 클래스 방향에 빈 마름모로 표시하고, or 관계에 놓이면 선 사이를 점선으로 잇고 {or} 표시
  - ![image](https://user-images.githubusercontent.com/107028310/210359378-068296f9-7219-4cb2-9197-7d14fb736406.png)

- UML 포함 관계(Composition Relation)

  - 부분 객체가 전체 객체에 속하는 강한 집합 연관의 관계를 표현하는 클래스
  - '부분' 객체는 다른 객체와 공유 불가, '전체' 객체 방향에 채워진 마름모로 표시
  - ![image](https://user-images.githubusercontent.com/107028310/210359125-60449683-265c-4de1-8adf-dc39484eb482.png)

- UML 실체화 관계(Realization Relation)

  - 인터페이스와 실제 구현된 일반 클래스 간의 관계로 존재하는 행도에 대한 구현을 표시
  - 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계
  - ![image](https://user-images.githubusercontent.com/107028310/210359560-251de9af-ef33-4590-9461-9dd1513b5567.png)

---

- Use Case Diagram의 개념

  - 객체지향 초반기 분석 작업에 작성되는 사용자의 요구를 기능적 측명에서 기술할 때 사용하는 도구로 Actor와 Use Case 로 구성
  - 얻어지는 결과는 개발 대상 시스템이 제공해야 하는 서비스 목록이 됨

- Use Case Diagram 요소

  - | 요소                                 | 설명                                                         |
    | ------------------------------------ | ------------------------------------------------------------ |
    | 시스템 경계(System Boundary)         | 시스템이 제공해야 하는 사례들의 범위, 큰 규모의 객체로 구현되는 존재 |
    | 액터(Actor)                          | 서비스를 이용하는 외부 객체, 시스템이 유즈케이스를 실행토록 요구할 수 있는 존재 |
    | 유스케이스(Use Case)                 | 시스템이 제공해야 하는 개별 서비스 기능, 서비스는 특정 클래스의 멤버 함수로 모델링 |
    | 접속 관계(communication Association) | 액터/유스케이스 또는 유스케이스/유스케이스 사이에 연결되는 관계<br />액터나 유스케이스가 다른 유스케이스의 서비스를 이용하는 상황을 표현 |
    | 사용 관계(Uses Association)          | 여러개의 유스케이스에서 공통으로 수행해야 하는 기능을 모델링하기 위해 사용 |
    | 확장 관계(Extends Association)       | 확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성되는 관계<br />해당 유스케이스에 부가적인 유스케이스를 실행할 수 있을 때의 관계<br />확장대상 유스케이스를 수행 할 때 특정 조건에 따라 확장 기능 유스케이스를 수행하는 경우 적용 |

- Use Case Diagram 작성 단계

  - | 단계            | 설명                                                         |
    | --------------- | ------------------------------------------------------------ |
    | 액터 식별       | 모든 사용자 역할과 상호작용하는 타 시스템을 식별<br />정보를 주고받는 하드웨어 및 지능형 장치를 식별 |
    | Use Case 식별   | 액터가 요구하는 서비스와 정보 식별<br />액터가 시스템과 상호작용하는 행위 식별 |
    | 관계 정의       | 액터와 액터 그리고 액터와 유스케이스의 관계분석을 정의<br />유스케이스와 유스케이스 간의 관계 분석을 정의 |
    | Use Case 구조화 | 두 개의 상위 유스케이스에 존재하는 공통 서비스 추출<br />추출된 서비스로 유스케이스 정의<br />추출된 서비스를 사용하는 유스케이스와의 관계를 정의<br />조건에 따른 서비스 수행 부분 분석해 구조화 |

---

