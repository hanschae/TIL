# 정보처리기사 [필기]

[toc]

## 2. 소프트웨어 설계 2

### 11. 소프트웨어 설계 모델링

#### 01. 소프트웨어의 설계(Design)

- 소프트웨어 설계 모델링

  - 정의 : 요구사항을 만족하는 SW의 내부 구조 및 동적 행위들을 모델링해 표현하고 분석, 검증하는 과정 및 산출물
  - 목적 : "무엇"으로부터 "어떻게"로 관점을 전환하며 최종 제작할 SW의 청사진을 제작

- 소프트웨어 설계

  - 프로그램 구현 전 SW를 구성하는 뼈대를 정의해 구현 기반을 만드는 것, 상위 설계와 하위 설계로 구분

- 설계의 기본 원리

  - 분할과 정복, 추상화, 단계적 분해, 모듈화, 정보 은닉

- 소프트웨어 설계 분류

  - 상위 설계 : 아키텍처 설계 - 데이터 설계 - 시스템 분할 - 인터페이스 설계
  - 하위 설계 : 모듈 설계 - 자료 구조 설계 - 알고리즘 설계

- 상위 설계(High-Level Design)

  - 아키텍처 설계(Architecture Design), 예비 설계(Preliminary Design), 전체 골조를 세우는 단계
  - 아키텍처 설계 : 시스템의 전체적인 구조
  - 데이터 설계 : 시스템에 필요한 정보를 자료 구조/데이터베이스 설계에 반영
  - 시스템 분할 : 전체 시스템을 여러 개의 서브 시스템으로 분리
  - 인터페이스 설계 : 시스템의 구조와 서브 시스템들 사이의 관계
  - 사용자 인터페이스 설계 : 사용자와 시스템의 관계

- 하위 설계(Low-Level Design)

  - 모듈 설계(Module Design), 상세 설계(Detail Design), 시스템 각 구성 요소의 제어와 데이터 간의 연결에 대한 구체적 정의
  - 하위 설계 방법 : 절차 기반(Procedure-Oriented), 자료 위주(Data-Oriented), 객체지향(Object-Oriented) 설계 방법

- 모듈(Module)이 되기 위한 주요 특징

  - 다른 것들과 구별될 수 있는 독립적 기능을 가진 단위(Unit)
  - 독립적 컴파일 가능, 유일한 이름 보유
  - 다른 모듈에서 접근 가능

- 소프트웨어 설계 대상

  - | 구분        | 설명                                                         |
    | ----------- | ------------------------------------------------------------ |
    | 구조 모델링 | SW 구성하는 컴포넌트의 유형, 인터페이스, 내부 설계 구조 등 구조의 상호 연결 등의 구조를 모델링<br />구성 요소에는 프로시저, 데이터 구조, 모듈, 파일 구조 등이 있음<br />구성 요소들의 연결 구조, 포함 관계를 시스템 구조라 칭함 |
    | 행위 모델링 | SW의 구성 요소들 기능과 구성 요소들이 언제 어떤 순서로 기능을 수행하고 상호작용 하는지 모델링<br />시스템 각 구성 요소들의 기능적 특성 모델링<br />입출력 데이터, 데이트 흐름과 변환, 데이터 저장, 실행 경로, 상태 전이, 이벤트, 발생 순서 등 |

- 소프트웨어 설계 방법

  - | 구분           | 설명                                                         |
    | -------------- | ------------------------------------------------------------ |
    | 구조적 설계    | 기능적 관점으로 SW에 요구된 기능이나 자료 처리 과정, 알고리즘 등을 중심으로 시스템을 나눠 설계<br />시스템의 각 모듈은 최상위 기능에서 하위 기능으로 하향적으로 세분화 |
    | 자료 중심 설계 | 입 출력 자료의 구조를 파악해 SW 자료구조를 설계하는 방식<br />Jackson Warner-Orr |
    | 객체지향 설계  | 자료와 자료에 적용될 기능을 함께 묶어 추상화하는 개념<br />시스템은 객체로 구성<br />Yourdon, Sheller/Meller, Rumbaugh, Booch |

- 소프트웨어 구조도

  - SW 구성 요소인 모듈 간의 계층적 구성으로 프로그램 구조에서 사용되는 용어

  - | 용어명         | 설명                                   |
    | -------------- | -------------------------------------- |
    | Fan-in         | 주어진 한 모듈을 제어하는 상위 모듈 수 |
    | Fan-out        | 주어진 한 모듈이 제어하는 하위 모듈 수 |
    | Depth          | 최상위 모듈에서 주어진 모듈까지의 깊이 |
    | Width          | 같은 등급의 모듈 수                    |
    | Super ordinate | 다른 모듈을 제어하는 모듈              |
    | Subordinate    | 어떤 모듈에 의해 제어되는 모듈         |

  - Fan-in/Fan-out 분석 시 시스템 복잡도 파악이 가능

  - Fan-in이 높은 경우 : 재사용 측면에서 잘된 설계 / 시스템 구성 요소 중 일부가 동작하지 않으면 시스템이 중단되는 단일 장애 발생 가능성 / 단일 장애 발생을 방지하기 위해 중점 관리가 필요

  - Fan-out이 높은 경우 : 불필요한 타 모듈의 호출 여부 확인 / Fan-out을 단순하게 설계할 수 있는지 검토

  - 복잡도 최적화를 위한 조건 : Fan-in은 높이고 Fan-out은 낮추도록 설계

#### 02. 코드 설계의 개요

- 코드 설계

  - 데이터의 사용 목적에 따라 식별 분류, 배열하기 위해 사용하는 숫자, 문자 혹은 기호가 코드
  - 대량의 자료를 구별, 동질의 그룹으로 분류하고 순번으로 나열, 특정의 자료를 선별하거나 추출을 쉽게 하여 파일 시스템을 체계화 한 것을 코드 설계
  - 코드 설계 순서 : 코드 대상 선정 > 코드화 목적 명확화 > 코드 부여 대상 수 확인 > 사용 범위 결정 > 사용 기간 결정 > 코드화 대상의 특성 분석 > 코드 부여 방식 결정 > 코드의 문서화

- 코드의 기능

  - | 코드의 기본적 기능           | 코드의 3대 기능                         | 코드의 부가적 기능                             |
    | ---------------------------- | --------------------------------------- | ---------------------------------------------- |
    | 표준적 기능<br />간소화 기능 | 분류 기능<br />식별 기능<br />배열 기능 | 연상 기능<br />암호화 기능<br />오류 검출 기능 |

- 코드 설계 목적 및 특성

  - | 목적              | 특성                                      |
    | ----------------- | ----------------------------------------- |
    | 고유성            | 코드는 뜻이 1:1로 확실히 대응 가능해야 함 |
    | 분류 편리성       | 목적에 적합한 분류 가능해야 함            |
    | 배열의 효율성     | 바람직한 배열 얻을 수 있어야 함           |
    | 간결성            | 짧고 간결 명료해야 함                     |
    | 유지보수 편리성   | 유지 관리가 쉬워야 함                     |
    | 코드의 독립성     | 다른 코드 체계와 중복되지 않아야 함       |
    | 코드의 편의성     | 이해가 쉽고 사용하는데 편리해야 함        |
    | 추가, 삭제 편리성 | 추가와 삭제가 편리해야 함                 |

- 코드 설계 시 고려사항

  - | 사항              | 특성               |
    | ----------------- | ------------------ |
    | 기계처리의 적합성 | 컴퓨터 처리에 적합 |
    | 사용의 편리성     | 취급하기 쉽게      |
    | 코드의 공통성     | 공통성이 있도록    |
    | 코드의 체계성     | 체계적             |
    | 코드의 유연성     | 확장성             |

#### 03. 코드의 종류

- 순차 코드(Sequence Code)

  - 코드화 대상 항목을 어떤 일정한 배열로 일련번호를 배당하는 코드로 확장성이 좋으며 단순해 이해하기 쉽고 기억하기 쉬움
  - 항목 수가 적고 변경이 적은 자료에 적합, 일정 순서대로 코드를 할당하므로 기억 공간의 낭비가 적음
  - 누락된 번호를 삽입하기 어렵고 명확한 분류 기준이 없어 코드에 따라 분류가 어려워 융통성 낮음

- 블록 코드(Block Code, 구분 코드)

  - 코드화 대상 항목에 미리 공통의 특성에 따라서 임의의 크기를 블록으로 구분해 각 블록안에서 일련번호를 배정하는 코드
  - 기계 처리가 어렵고 블록마다 여유 코드를 두어 코드 추가가 용이하나 여유 코드는 코드 낭비의 원인이 됨

- 그룹 분류식 코드(Group Classification Code)

  - 코드화 대상 항목을 소정의 기준에 따라 대,중,소분류로 구분해 순서대로 번호를 부여하는 코드
  - 분류 기준이 명확한 경우 이용도가 높으며 기계처리에 가장 적합
  - 여유 부분이 있어 자료 추가를 쉽게 처리 가능하나 자릿수가 길어질 수 있음

- 10진 분류 코드(Decimal Code)

  - 좌측 부는 그룹 분류에 따르고 우측은 10진수의 원칙에 따라 세분화하는 코드
  - 무한하게 확대가능, 대량의 자료에 대한 삽입 및 추가가 용이
  - 자릿수가 많아지고 기계 처리가 불편하지만 배열이나 집계가 쉬움, 주로 도서 코드에 사용 (예 : 100 국문학, 200 철학)

- 표의 숫자 코드(Significant Digit Code, 유효 숫자 코드)

  - 코드화 대상 항목의 길이, 넓이, 부피, 무게 등을 나타내는 문자나 기호를 그대로 사용하는 코드
  - 코드의 추가 및 삭제가 용이하며 같은 코드를 반복하여 사용하므로 오류가 적음 (예 : 127-890-1245 / 두께 127mm, 폭 890mm, 길이 1,245mm의 강판)

- 연상 코드(Mnemonic Code, 기호 코드)

  - 코드화 대상의 품목 명칭 일부를 약호 형태로 코드 속에 넣어 대상 항목을 쉽게 알 수 있는 코드 (예 : TV-39-C / TV 39인치 컬러)

- 코드의 오류 종류

  - | 오류                                  | 의미                                       | 예           |
    | ------------------------------------- | ------------------------------------------ | ------------ |
    | 필사 오류(Transcription Error)        | 입력 시 한 자리를 잘못 기록하는 오류       | 1234 > 1237  |
    | 전위 오류(Transposition Error)        | 입력 시 좌우 자리를 바꾸어 발생하는 오류   | 1234 > 1243  |
    | 이중 오류(Double Transposition Error) | 전위 오류가 두 개 이상 발생하는 오류       | 1234 > 2143  |
    | 생략 오류(Missing Error)              | 입력 시 한 자리를 빼고 기록하는 오류       | 1234 > 123   |
    | 추가 오류(Addition Error)             | 입력 시 한 자리를 추가해서 기록하는 오류   | 1234 > 12345 |
    | 임의 오류(Random Error)               | 두 가지 이상의 오류가 결합해 발생하는 오류 | 1234 > 21345 |

#### 04. 구조적 개발 방법론

- 구조적 분석
  - 자료의 흐름, 처리를 중심으로 한 요구분석 방법, 전체 시스템의 이해를 돕는 분석 도구로 모형화에 필요한 도구 제공 및 시스템을 나누어 분석 가능
  - 정형화 된 분석 절차에 따라 요구사항을 파악, 문서화 하는 분석 방법으로 자료 흐름도, 자료 사전, 소단위 명세를 사용
  - 시스템 분할이 가능하며 하향식 분석 기법을 사용하고 분석자와 사용자 간의 의사소통에 도움
- 구조적 설계의 특징과 기본 구조
  - 특징 : 하향식 기법, 신뢰성 향상, 유연성 제공, 재사용 용이
  - 기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조 = 조건(Condition) 구조, 반복(Repetition) 구조

#### 05. 구조적 분석 도구

- 자료 흐름도(DFD : Data Flow Diagram)
  - 시스템 내 모든 자료 흐름은 4가지 기본 기호(처리, 자료 흐름, 자료 저장소, 단말)로 기술하고 자료 흐름을 중심으로 한 분석용 도구
  - DFD의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시하며 구조적 분석 기법이 이용
  - 시스템이나 프로그램 간의 총체적 데이터 흐름을 표시 가능하며 기본적 데이터 요소나 그들 사이의 데이터 흐름 형태로 기술
  - 다차원적이며 자료 흐름 그래프 또는 버블 차트라고도 함
  - 그림 중심의 표현이고 하향식 분할 원리 적용
  - 갱신하기 쉬워야 하며 이름의 중복을 제거해 이름으로 정의를 쉽게 찾을 수 있도록 하며 정의하는 방식이 명확해야 함
- 자료 흐름도(DFD) 작성 원칙
  - 출력 자료 흐름은 입력 자료 흐름을 이용해 생성
  - 입출력 자료 자체에 대해서만 인지하고 자료의 위치나 방향은 알 필요가 없음
  - 자료 흐름 변환의 형태에는 본질 변환, 합성의 변환, 관점의 변환, 구성의 변환 등이 있음
  - 자료 보존의 원칙 : 출력 자료 흐름은 반드시 입력 자료 흐름을 이용해 생성
  - 최소 자료 입력의 원칙 : 출력 자료를 산출하는데 필요한 최소의 자료 흐름만 입력
  - 독립성의 원칙 : 프로세스는 오직 자신의 입력 자료와 출력 자료 자체에 대해서만 알면 됨
  - 지속성의 원칙 : 프로세스는 항상 수행하고 있어야 함
  - 순차 처리의 원칙 : 입력 자료 흐름의 순서는 출력되는 자료 흐름에서도 지키도록 함
  - 영구성의 원칙 : 자료 저장소의 자료는 입력으로 사용해도 삭제되지 않음
- 데이터(자료) 흐름도
  - ![image](https://user-images.githubusercontent.com/107028310/210788809-855a3f1a-ecce-4e5c-b75a-87b616f8c9a2.png)
- 소단위 명세서(Mini-Specification)
  - 세분화된 자료 흐름도에서 최하위 단계 프로세스의 처리절차를 설명
  - 세분화된 자료 흐름도에서 최하위 단계 버블의 처리 절차를 기술한 것으로 프로세스 명세서라고도 함
  - 분석가의 문서이며 자료 흐름도(DFD)를 지원하기 위해 작성
  - 서술 문장, 구조적 언어, 의사 결정 나무, 의사 결정표, 그래프 등을 이용하여 기술
- 구조적 언어, 의사 결정 나무, 의사 결정표
  - 구조적 언어 : 자연어 일부분으로 한정된 단어와 문형, 제한된 구조를 사용해 명세서를 작성하는데 이용하는 명세 언어
  - 의사 결정 나무 : 현재 상황과 목표와의 상호 관련성을 나무의 가지를 이용해 표현한 것으로 불확실한 상황에서의 의사결정을 위한 분석 방법
  - 의사 결정표 : 복잡한 의사결정 논리를 기술하는데 사용, 주로 자료 처리 분야에서 이용
- 자료 사전(DD : Data Dictionary)
  - 시스템과 관련된 모든 자료의 명세와 자료 속성을 파악할 수 있도록 조직화한 도구
  - ![image](https://user-images.githubusercontent.com/107028310/210789722-ee14132f-8578-4879-8eb7-4eca2cbcf9ee.png)
- 자료 사전의 역할
  - 자료 흐름도에 기술한 모든 자료의 정의를 기술한 문서로 구조적 시스템 방법론에서 자료 흐름도, 소단위 명세서와 더불어 중요한 분석 문서
  - 자료 사전 이해도를 높이고자 할 때는 하향식 분할 원칙에 맞추어 구성 요소를 재정의
- 자료 사전에서 기술해야 할 자료
  - 자료 흐름을 구성하는 자료 항목, 자료 저장소를 구성하는 자료 항목, 자료에 대한 의미, 자료 원소의 단위 및 값 등이 있다.

---

### 12. 모듈

#### 01. 모듈과 결합도, 응집도

- 모듈

  - 전체 프로그램에서 기능을 수행할 수 있는 실행 코드를 의미하며 재사용 가능, 자체적 컴파일이 가능
  - 시스템 개발 시 기간과 노동력 절감이 가능하며 모듈의 독립성은 결합도와 응집도에 의해 측정됨
  - 서브루틴 = 서브 시스템 = 작업 단위
  - 변수의 선언을 효율적으로 할 수 있어 기억 장치를 유용하게 사용 가능
  - 모듈마다 사용할 변수를 정의하지 않고 상속해 사용 가능
  - 각 묘듈의 기능이 서로 다른 모듈과 과도한 상호작ㄱ용을 회피함으로서 이루어지는 것을 기능적 독립성이라 부름

- 결합도(Coupling)

  - 서로 다른 두 모듈 간의 상호 의존도로서 두 묘둘간의 기능적 연관 정도를 나타냄

  - 모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상되어 시스템 구현과 유지보수가 쉬워짐

  - 자료 결합도가 설계 품질이 가장 좋다

  - | 결합도      | 종류          | 설명                                                         |
    | ----------- | ------------- | ------------------------------------------------------------ |
    | 결합도 약함 | 자료 결합도   | 모듈 간의 인터페이스가 자료 요소로만 구성된 경우로 다른 모듈에 영향 주지 않는 가장 바람직한 결합도<br />모듈간의 내용을 전혀 알 필요가 없다 |
    | ↑           | 스탬프 결합도 | 두 모듈이 같은 자료 구조를 조회하는 경우의 결합도<br />자료구조의 변화 즉 포맷이나 구조의 변화는 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈까지도 영향을 미침<br />배열, 레코드, 구조 등이 모듈 간 인터페이스로 전달되는 경우와 관계 |
    | ↑           | 제어 결합도   | 어떤 모듈이 타 모듈의 내부 논리 조작을 제어하기 위해 제어 신호를 이용해 통신하는 경우<br />하위 모듈에서 상위 모듈로 제어 신호가 이동해 상위 모듈에 처리 명령을 부여하는 권리 전도 현상 발생 |
    | ↓           | 외부 결합도   | 어떤 모듈에서 외부로 선언한 변수를 다른 모듈에서 참조할 경우 관계 |
    | ↓           | 공통 결합도   | 여러 모듈이 공통 자료 영역을 사용하는 경우<br />공통 데이터 영역 내용을 수정하면 이 데이터를 사용하는 모든 모듈에 영향 |
    | 결합도 강함 | 내용 결합     | 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 조회하도록 설계 되었을 경우 관계<br />한 모듈에서 다른 모듈의 내부로 제어 및 이동되며 내부 자료 조회, 변경, 같은 문자의 공유가 가능 |

- 응집도(Cohesion)

  - Myers가 구분한 명령어, 명령어의 모임, 호출문, 특정 작업 수행 코드 등 모듈안의 요소들이 서로 관련된 정도

  - 구조적 설계에서 기능 수행 시 모듈 간 최소한의 상호작용을 해 하나의 기능만을 수행하는 정도 푷녀

  - 모듈이 독립적 기능으로 구성됨의 정도

  - 응집도가 높다는 건 구성됨의 정도를 의미

  - 응집도가 낮다는 것은 요소간의 관련성이 적음을 의미

  - | 응집도      | 종류          | 설명                                                         |
    | ----------- | ------------- | ------------------------------------------------------------ |
    | 응집도 강함 | 기능적 응집도 | 모듈 내부의 모든 기능 요소들이 한 문제와 연관되어 수행되는 경우와 관계 |
    | ↑           | 순차적 응집도 | 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 요소의 입력 자료로 제공되는 경우와 관계 |
    | ↑           | 교환적 응집도 | 같은 입출력을 사용하는 소 작업이 모인 경우와 관계            |
    |             | 절차적 응집도 | 모듈이 다수의 관련 기능을 가질 때 모듈 내부의 기능 요소들이 그 기능을 순차적 수행 할 경우와 관계 |
    | ↓           | 시간적 응집도 | 특정 시간에 처리되는 여러 기능을 모아 한 개의 모듈로 작성할 경우와 관계 |
    | ↓           | 논리적 응집도 | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들과 하나의 모듈이 형성되는 경우와 관계 |
    | 응집도 약함 | 우연적 응집도 | 모듈 내부의 각 기능 요소들이 서로 관련이 없는 요소로만 구성된 경우와 관계 |

- 효과적인 모듈화 설계 방법

  - 응집도는 강하게, 결합도는 약하게 설계해 모듈의 독립성을 보장하고, 유지보수가 용이토록 설계
  - 출입구를 하나씩 갖게 하고 모듈간 접속 관계를 분석해 복잡도와 중복성을 줄이고 일관성을 유지할 수 있도록 설계
  - 모듈 크기는 전반적 기능과 구조를 이해하기 쉬운 크기로 설계
  - 모듈 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안됨
  - 모듈 간 효과적 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 하며 적당한 모듈 크기를 유지

- 모듈 설계의 특징

  - 모듈 독립성이 높다는 것은 단위 모듈을 변경하더라도 타 모듈에 영향이 적다는 의미로 오류 발견과 해결이 쉬워짐
  - 모듈 인터페이스 설계 시 인덱스 번호, 기능 코드 등 전반적인 논리 구조에 영향을 끼치지 않도록 함

#### 02. 모듈과 컴포넌트

- 모듈 vs 컴포넌트

  - | 모듈                                                         | 컴포넌트                                                     |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 자신만으로 동작 가능한 명령의 집합<br />실제로 가장 맨 앞에 위치하는 구현된 단위이며 자료 구조, 알고리즘 등 이 제공하는 인터페이스<br />정의하지 않는 이상 바로 재활용 불가능 | SW 시스템에서 독립적 업무 및 기능을 수행하는 모듈로 교체가 가능한 부품<br />모듈화로 생산성을 향상했으나 모듈의 소스 코드 레벨의 재활용으로 인한 한계성 극복을 위해 등장<br />인터페이스를 통해 연결 |
    | 1개 서버에 100개의 클라이언트가 서비스 받고 있을 때,<br />서버 1 + 서비스 구현된 모듈 1개로 총 모듈은 2개 | 1개 서버에 100개의 클라이언트가 서비스 받고 있을 때,<br />실제 동작 서버 1 + 클라이언트 100개로 총 101 |

- 모듈, 컴포넌트, 서비스 특징 비교

  - | 구분        | 모듈                                                 | 컴포넌트                                              |
    | ----------- | ---------------------------------------------------- | ----------------------------------------------------- |
    | 주요 목적   | SW 복잡도 해소                                       | SW 재사용성 향상                                      |
    | 재사용 단위 | 소스 코드                                            | 실행 코드                                             |
    | 독립성      | 구현 언어 종속적, 플랫폼에 종속적                    | 구현 언어 종속적, 동일 플랫폼 기반 개별적 연계        |
    | 응용        | 단일 애플리케이션                                    | 분산 애플리케이션                                     |
    | 중심사상    | 모듈화, 추상화                                       | 객체지향, CBD                                         |
    | 호출 방법   | 함수 호출                                            | 구현 기술 인터페이스                                  |
    | 서비스 특징 | 여러 모듈이 하나의 애플리케이션을 형성하는 계층 구조 | 다른 컴포넌트와 커뮤니케이션 네트워크를 이루며 서비스 |

- 모듈 분할의 특징

  - 설계의 질이 측정 가능하며 유지보수, 재사용이 쉬움
  - 모듈 분할 시 영향을 주는 설계 형태 : 추상화, 모듈화, 정보 은폐, 복잡도, 시스템 구조

#### 03. 재사용과 공통 모듈

- 재사용
  - 검증된 기능을 파악해 재구성하는 것을 의미하며 새로운 개발 방법론 도입이 어려움
  - 모듈 최적화를 통해 타 시스템에 적용하면 개발 비용 및 기간 단축 가능
  - 생산성 및 SW 품질 향상
  - 재사용 시 해당 모듈은 외부 모듈과의 응집도는 높고, 결합도는 낮아야 함
  - 기존 SW에 재사용 SW를 추가하기 어려운 문제점이 발생 가능
- 재사용 규모에 따른 구분
  - 함수와 객체 : 클래스, 메소드 단위로 소스 코드 등을 재사용
  - 애플리케이션 : 공통 업무를 처리할 수 있도록 구현된 애플리케이션을 공유해 재사용
  - 컴포넌트 : 컴포넌트 자체 수정 없이 인터페이스를 통해 컴포넌트 단위로 재사용
- 공통 모듈
  - 각 서브 시스템에서 공통 사용하는 기능(날짜 처리 등)을 묶어 하나의 공통 모듈로 개발
  - 모듈 재사용성을 높이고 중복 개발로 인한 낭비를 없애기 위해 설계 단계에서 공통 모듈을 분리
  - 같은 기능 재사용함으로 기능에 대한 정합성 유지 및 중복 개발 방지
  - 유지보수 단계에서도 모듈 변경을 통해 관련된 시스템 일괄 변경 가능
  - 재사용 범위에 따른 분류 : 함수와 객체 재사용, 컴포넌트 재사용 , 애플리케이션 재사용
- 공통 모듈 - 명세 기법
  -  정확성 : 실제 구현 시 꼭 필요한 기능인지 확인 가능토록 정확히 작성
  - 명확성 : 해당 기능에 대한 일관된 이해와 하나로 해석 가능토록 작성
  - 완전성 : 시스템 구현 시 필요한 것, 요구되는 것을 모두 작성
  - 일관성 : 공통 기능 간 서로 충돌이 발생하지 않도록 작성
  - 추적성 : 공통 기능에 대한 요구사항 출처, 관련 시스템이 유기적 관계 구분이 가능토록 작성
- 모듈 명세화 도구
  - 흐름도(Flowchart), N-S도표(Nassi-SchneidermanChart), 의사 코드(Pseudo Code), 의사 결정표(Decision Table), 의사 결정도(Decision Diagram), 상태 전이도(State Design Language), PDL(Program Design Language), 행위도(Action Diagram)
- N-S 도표(Nassi-Schneiderman Chart)
  - 구조적 프로그램의 순차, 선택, 반복의 구조를사각형으로 도식화 해 알고리즘을 논리적 기술에 중점을 둔 도형식 표현 방법
  - 이해하기 쉽고 코드 변환이 용이하며 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합
  - 제어구조 : 순차(연속, Sequence), 선택 및 다중 선택(If~Then~Else,Case), 반복(Repeat~Until, While, For)
  - 주로 박스 다이어그램을 사용해 논리적 제어 구조로 흐름을 표현
  - ![image](https://user-images.githubusercontent.com/107028310/211023365-d16d8c78-d6a9-44f6-a94f-0255c759615c.png)

---





